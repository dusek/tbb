<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_hash_map.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_hash_map.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_hash_map_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_hash_map_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00025 <span class="preprocessor">#include &lt;iterator&gt;</span>
00026 <span class="preprocessor">#include &lt;utility&gt;</span>      <span class="comment">// Need std::pair</span>
00027 <span class="preprocessor">#include &lt;cstring&gt;</span>      <span class="comment">// Need std::memset</span>
00028 <span class="preprocessor">#include &lt;string&gt;</span>
00029 <span class="preprocessor">#include "tbb_stddef.h"</span>
00030 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00031 <span class="preprocessor">#include "tbb_allocator.h"</span>
00032 <span class="preprocessor">#include "spin_rw_mutex.h"</span>
00033 <span class="preprocessor">#include "atomic.h"</span>
00034 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;typeinfo&gt;</span>
00036 <span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>
00038 <span class="keyword">namespace </span>tbb {
00039 
00040 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>tbb_hash_compare;
00041 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare = tbb_hash_compare&lt;Key&gt;, <span class="keyword">typename</span> A = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt; &gt;
00042 <span class="keyword">class </span>concurrent_hash_map;
00043 
00045 <span class="keyword">namespace </span>internal {
<a name="l00047"></a><a class="code" href="a00309.html#a2">00047</a>     <span class="keyword">typedef</span> size_t hashcode_t;
<a name="l00049"></a><a class="code" href="a00217.html">00049</a>     <span class="keyword">class </span><a class="code" href="a00217.html">hash_map_base</a> {
00050     <span class="keyword">public</span>:
00051         <span class="comment">// Mutex types for each layer of the container</span>
00052         <span class="keyword">typedef</span> <a class="code" href="a00244.html">spin_rw_mutex</a> <a class="code" href="a00244.html">node_mutex_t</a>;
00053         <span class="keyword">typedef</span> <a class="code" href="a00244.html">spin_rw_mutex</a> <a class="code" href="a00244.html">chain_mutex_t</a>;
00054         <span class="keyword">typedef</span> <a class="code" href="a00244.html">spin_rw_mutex</a> <a class="code" href="a00244.html">segment_mutex_t</a>;
00055 
<a name="l00057"></a><a class="code" href="a00217.html#w3">00057</a>         <span class="keyword">typedef</span> <a class="code" href="a00309.html#a2">internal::hashcode_t</a> hashcode_t;
<a name="l00059"></a><a class="code" href="a00217.html#s0">00059</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment_bits = 6;
<a name="l00061"></a><a class="code" href="a00217.html#s1">00061</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment = size_t(1)&lt;&lt;n_segment_bits; 
<a name="l00063"></a><a class="code" href="a00217.html#s2">00063</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_physical_size = size_t(1)&lt;&lt;(8*<span class="keyword">sizeof</span>(hashcode_t)-n_segment_bits);
00064     };
00065 
00066     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00067     <span class="keyword">class </span><a class="code" href="a00218.html">hash_map_range</a>;
00068 
00069     <span class="keyword">struct </span>hash_map_segment_base {
00071         <a class="code" href="a00244.html">hash_map_base::segment_mutex_t</a> my_mutex;
00072 
00073         <span class="comment">// Number of nodes</span>
00074         <a class="code" href="a00186.html">atomic&lt;size_t&gt;</a> my_logical_size;
00075 
00076         <span class="comment">// Size of chains</span>
00078 <span class="comment"></span>        size_t my_physical_size;
00079 
00081 
00082         <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_grow_predicate() <span class="keyword">const</span>;
00083     };
00084 
00086 
00088     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00089     <span class="keyword">class </span>hash_map_iterator
<a name="l00090"></a><a class="code" href="a00309.html#a38">00090</a> #if <a class="code" href="a00309.html#a38">defined</a>(_WIN64) &amp;&amp; <a class="code" href="a00309.html#a38">defined</a>(_MSC_VER) 
00091         <span class="comment">// Ensure that Microsoft's internal template function _Val_type works correctly.</span>
00092         : public std::iterator&lt;std::forward_iterator_tag,Value&gt;
00093 #endif <span class="comment">/* defined(_WIN64) &amp;&amp; defined(_MSC_VER) */</span>
00094     {
00095         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::node node;
00096         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::chain chain;
00097         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::segment segment;
00098 
00100         Container* my_table;
00101 
00103         node* my_node;
00104 
00106         size_t my_array_index;
00107 
00109         size_t my_segment_index;
00110 
00111         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00112         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> hash_map_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;C,U&gt;&amp; j );
00113 
00114         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00115         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> hash_map_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;C,U&gt;&amp; j );
00116 
00117         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00118         <span class="keyword">friend</span> ptrdiff_t operator-( <span class="keyword">const</span> hash_map_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;C,U&gt;&amp; j );
00119     
00120         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U&gt;
00121         <span class="keyword">friend</span> <span class="keyword">class </span>internal::hash_map_iterator;
00122 
00123         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00124         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00218.html">internal::hash_map_range</a>;
00125 
00126         <span class="keywordtype">void</span> advance_to_next_node() {
00127             size_t i = my_array_index+1;
00128             <span class="keywordflow">do</span> {
00129                 segment &amp;s = my_table-&gt;my_segment[my_segment_index];
00130                 <span class="keywordflow">while</span>( i&lt;s.my_physical_size ) {
00131                     my_node = s.my_array[i].node_list;
00132                     <span class="keywordflow">if</span>( my_node ) <span class="keywordflow">goto</span> done;
00133                     ++i;
00134                 }
00135                 i = 0;
00136             } <span class="keywordflow">while</span>( ++my_segment_index&lt;my_table-&gt;n_segment );
00137         done:
00138             my_array_index = i;
00139         }
00140 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00141 <span class="preprocessor"></span>        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00142         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00196.html">tbb::concurrent_hash_map</a>;
00143 <span class="preprocessor">#else</span>
00144 <span class="preprocessor"></span>    <span class="keyword">public</span>: <span class="comment">// workaround</span>
00145 <span class="preprocessor">#endif</span>
00146 <span class="preprocessor"></span>        hash_map_iterator( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index=0, node* b=NULL );
00147     <span class="keyword">public</span>:
00149         hash_map_iterator() {}
00150         hash_map_iterator( <span class="keyword">const</span> hash_map_iterator&lt;Container,typename Container::value_type&gt;&amp; other ) :
00151             my_table(other.my_table),
00152             my_node(other.my_node),
00153             my_array_index(other.my_array_index),
00154             my_segment_index(other.my_segment_index)
00155         {}
00156         Value&amp; operator*()<span class="keyword"> const </span>{
00157             __TBB_ASSERT( my_node, <span class="stringliteral">"iterator uninitialized or at end of container?"</span> );
00158             <span class="keywordflow">return</span> my_node-&gt;item;
00159         }
00160         Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00161         hash_map_iterator&amp; operator++();
00162         
00164         Value* operator++(<span class="keywordtype">int</span>) {
00165             Value* result = &amp;operator*();
00166             operator++();
00167             <span class="keywordflow">return</span> result;
00168         }
00169 
00170         <span class="comment">// STL support</span>
00171 
00172         <span class="keyword">typedef</span> ptrdiff_t difference_type;
00173         <span class="keyword">typedef</span> Value value_type;
00174         <span class="keyword">typedef</span> Value* pointer;
00175         <span class="keyword">typedef</span> Value&amp; reference;
00176         <span class="keyword">typedef</span> <span class="keyword">const</span> Value&amp; const_reference;
00177         <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;
00178     };
00179 
00180     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00181     hash_map_iterator&lt;Container,Value&gt;::hash_map_iterator( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index, node* b ) : 
00182         my_table(const_cast&lt;Container*&gt;(&amp;table)),
00183         my_node(b),
00184         my_array_index(array_index),
00185         my_segment_index(segment_index)
00186     {
00187         <span class="keywordflow">if</span>( segment_index&lt;my_table-&gt;n_segment ) {
00188             <span class="keywordflow">if</span>( !my_node ) {
00189                 segment &amp;s = my_table-&gt;my_segment[segment_index];
00190                 chain* first_chain = s.my_array;
00191                 <span class="keywordflow">if</span>( first_chain &amp;&amp; my_array_index &lt; s.my_physical_size)
00192                     my_node = first_chain[my_array_index].node_list;
00193             }
00194             <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00195         }
00196     }
00197 
00198     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00199     hash_map_iterator&lt;Container,Value&gt;&amp; hash_map_iterator&lt;Container,Value&gt;::operator++() {
00200         my_node=my_node-&gt;next;
00201         <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00202         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00203     }
00204 
00205     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00206     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00207         <span class="keywordflow">return</span> i.my_node==j.my_node;
00208     }
00209 
00210     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00211     <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00212         <span class="keywordflow">return</span> i.my_node!=j.my_node;
00213     }
00214 
00216 
00217     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00218"></a><a class="code" href="a00218.html">00218</a>     <span class="keyword">class </span><a class="code" href="a00218.html">hash_map_range</a> {
00219     <span class="keyword">private</span>:
00220         Iterator my_begin;
00221         Iterator my_end;
00222         <span class="keyword">mutable</span> Iterator my_midpoint;
00223         size_t my_grainsize;
00225         <span class="keywordtype">void</span> set_midpoint() <span class="keyword">const</span>;
00226         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00218.html">hash_map_range</a>;
00227     <span class="keyword">public</span>:
<a name="l00229"></a><a class="code" href="a00218.html#w0">00229</a>         <span class="keyword">typedef</span> std::size_t size_type;
00230         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;
00231         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference;
00232         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::const_reference const_reference;
00233         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type;
00234         <span class="keyword">typedef</span> Iterator iterator;
00235 
<a name="l00237"></a><a class="code" href="a00218.html#a0">00237</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin==my_end;}
00238 
<a name="l00240"></a><a class="code" href="a00218.html#a1">00240</a>         <span class="keywordtype">bool</span> is_divisible()<span class="keyword"> const </span>{
00241             <span class="keywordflow">return</span> my_midpoint!=my_end;
00242         }
<a name="l00244"></a><a class="code" href="a00218.html#a2">00244</a>         <a class="code" href="a00218.html">hash_map_range</a>( <a class="code" href="a00218.html">hash_map_range</a>&amp; r, <a class="code" href="a00246.html">split</a> ) : 
00245             my_end(r.my_end),
00246             my_grainsize(r.my_grainsize)
00247         {
00248             r.<a class="code" href="a00218.html#r1">my_end</a> = my_begin = r.<a class="code" href="a00218.html#r2">my_midpoint</a>;
00249             __TBB_ASSERT( my_begin!=my_end, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00250             __TBB_ASSERT( r.<a class="code" href="a00218.html#r0">my_begin</a>!=r.<a class="code" href="a00218.html#r1">my_end</a>, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00251             set_midpoint();
00252             r.<a class="code" href="a00218.html#d0">set_midpoint</a>();
00253         }
00255         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
<a name="l00256"></a><a class="code" href="a00218.html#a3">00256</a>         <a class="code" href="a00218.html">hash_map_range</a>( <a class="code" href="a00218.html">hash_map_range&lt;U&gt;</a>&amp; r) : 
00257             my_begin(r.my_begin),
00258             my_end(r.my_end),
00259             my_midpoint(r.my_midpoint),
00260             my_grainsize(r.my_grainsize)
00261         {}
<a name="l00263"></a><a class="code" href="a00218.html#a4">00263</a>         <a class="code" href="a00218.html">hash_map_range</a>( <span class="keyword">const</span> Iterator&amp; begin_, <span class="keyword">const</span> Iterator&amp; end_, size_type grainsize = 1 ) : 
00264             my_begin(begin_), 
00265             my_end(end_), 
00266             my_grainsize(grainsize) 
00267         {
00268             set_midpoint();
00269             __TBB_ASSERT( grainsize&gt;0, <span class="stringliteral">"grainsize must be positive"</span> );
00270         }
00271         <span class="keyword">const</span> Iterator&amp; begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin;}
00272         <span class="keyword">const</span> Iterator&amp; end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_end;}
<a name="l00274"></a><a class="code" href="a00218.html#a7">00274</a>         size_type grainsize()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_grainsize;}
00275     };
00276 
00277     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00278     <span class="keywordtype">void</span> hash_map_range&lt;Iterator&gt;::set_midpoint()<span class="keyword"> const </span>{
00279         size_t n = my_end.my_segment_index - my_begin.my_segment_index;
00280         <span class="keywordflow">if</span>( n &gt; 1 || (n == 1 &amp;&amp; my_end.my_array_index &gt; my_grainsize/2) ) {
00281             <span class="comment">// Split by groups of segments</span>
00282             my_midpoint = Iterator(*my_begin.my_table,(my_end.my_segment_index+my_begin.my_segment_index+1)/2u);
00283         } <span class="keywordflow">else</span> {
00284             <span class="comment">// Split by groups of nodes</span>
00285             size_t m = my_end.my_array_index-my_begin.my_array_index;
00286             <span class="keywordflow">if</span>( n ) m += my_begin.my_table-&gt;my_segment[my_begin.my_segment_index].my_physical_size;
00287             <span class="keywordflow">if</span>( m &gt; my_grainsize ) {
00288                 my_midpoint = Iterator(*my_begin.my_table,my_begin.my_segment_index,my_begin.my_array_index + m/2u);
00289             } <span class="keywordflow">else</span> {
00290                 my_midpoint = my_end;
00291             }
00292         }
00293         __TBB_ASSERT( my_begin.my_segment_index &lt; my_midpoint.my_segment_index
00294             || (my_begin.my_segment_index == my_midpoint.my_segment_index
00295             &amp;&amp; my_begin.my_array_index &lt;= my_midpoint.my_array_index),
00296             <span class="stringliteral">"my_begin is after my_midpoint"</span> );
00297         __TBB_ASSERT( my_midpoint.my_segment_index &lt; my_end.my_segment_index
00298             || (my_midpoint.my_segment_index == my_end.my_segment_index
00299             &amp;&amp; my_midpoint.my_array_index &lt;= my_end.my_array_index),
00300             <span class="stringliteral">"my_midpoint is after my_end"</span> );
00301         __TBB_ASSERT( my_begin != my_midpoint || my_begin == my_end,
00302             <span class="stringliteral">"[my_begin, my_midpoint) range should not be empty"</span> );
00303     }
<a name="l00305"></a><a class="code" href="a00309.html#a3">00305</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="a00309.html#a2">hashcode_t</a> <a class="code" href="a00309.html#a3">hash_multiplier</a> = <span class="keyword">sizeof</span>(hashcode_t)==4? 2654435769U : 11400714819323198485ULL;
00307     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00308"></a><a class="code" href="a00309.html#a41">00308</a>     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="a00309.html#a2">hashcode_t</a> <a class="code" href="a00309.html#a41">hasher</a>( <span class="keyword">const</span> T&amp; t ) {
00309         <span class="keywordflow">return</span> static_cast&lt;hashcode_t&gt;( t ) * hash_multiplier;
00310     }
00311     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;
00312     <span class="keyword">inline</span> <span class="keyword">static</span> hashcode_t <a class="code" href="a00309.html#a41">hasher</a>( P* ptr ) {
00313         hashcode_t <span class="keyword">const</span> h = reinterpret_cast&lt;hashcode_t&gt;( ptr );
00314         <span class="keywordflow">return</span> (h &gt;&gt; 3) ^ h;
00315     }
00316     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> S, <span class="keyword">typename</span> A&gt;
00317     <span class="keyword">inline</span> <span class="keyword">static</span> hashcode_t <a class="code" href="a00309.html#a41">hasher</a>( <span class="keyword">const</span> std::basic_string&lt;E,S,A&gt;&amp; s ) {
00318         hashcode_t h = 0;
00319         <span class="keywordflow">for</span>( <span class="keyword">const</span> E* c = s.c_str(); *c; c++ )
00320             h = static_cast&lt;hashcode_t&gt;(*c) ^ (h * hash_multiplier);
00321         <span class="keywordflow">return</span> h;
00322     }
00323     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> S&gt;
00324     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="a00309.html#a2">hashcode_t</a> <a class="code" href="a00309.html#a41">hasher</a>( <span class="keyword">const</span> std::pair&lt;F,S&gt;&amp; p ) {
00325         <span class="keywordflow">return</span> <a class="code" href="a00309.html#a41">hasher</a>(p.first) ^ <a class="code" href="a00309.html#a41">hasher</a>(p.second);
00326     }
00327 } <span class="comment">// namespace internal</span>
00329 <span class="comment"></span>
00331 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00332"></a><a class="code" href="a00261.html">00332</a> <span class="keyword">struct </span><a class="code" href="a00261.html">tbb_hash_compare</a> {
00333     <span class="keyword">static</span> <a class="code" href="a00309.html#a2">internal::hashcode_t</a> hash( <span class="keyword">const</span> T&amp; t ) { <span class="keywordflow">return</span> internal::hasher(t); }
00334     <span class="keyword">static</span> <span class="keywordtype">bool</span> equal( <span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b ) { <span class="keywordflow">return</span> a == b; }
00335 };
00336 
00338 
00363 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00364"></a><a class="code" href="a00196.html">00364</a> <span class="keyword">class </span><a class="code" href="a00196.html">concurrent_hash_map</a> : <span class="keyword">protected</span> internal::hash_map_base {
00365     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00366     <span class="keyword">friend</span> <span class="keyword">class </span>internal::hash_map_iterator;
00367 
00368     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00369     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00218.html">internal::hash_map_range</a>;
00370 
00371     <span class="keyword">struct </span>node;
00372     <span class="keyword">friend</span> <span class="keyword">struct </span>node;
00373     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;node&gt;::other node_allocator_type;
00374 
00375 <span class="keyword">public</span>:
00376     <span class="keyword">class </span><a class="code" href="a00198.html">const_accessor</a>;
00377     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00198.html">const_accessor</a>;
00378     <span class="keyword">class </span><a class="code" href="a00197.html">accessor</a>;
00379 
00380     <span class="keyword">typedef</span> Key key_type;
00381     <span class="keyword">typedef</span> T mapped_type;
00382     <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00383     <span class="keyword">typedef</span> size_t size_type;
00384     <span class="keyword">typedef</span> ptrdiff_t difference_type;
00385     <span class="keyword">typedef</span> value_type *pointer;
00386     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;
00387     <span class="keyword">typedef</span> value_type &amp;reference;
00388     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type &amp;const_reference;
00389     <span class="keyword">typedef</span> internal::hash_map_iterator&lt;concurrent_hash_map,value_type&gt; iterator;
00390     <span class="keyword">typedef</span> internal::hash_map_iterator&lt;concurrent_hash_map,const value_type&gt; const_iterator;
00391     <span class="keyword">typedef</span> <a class="code" href="a00218.html">internal::hash_map_range&lt;iterator&gt;</a> <a class="code" href="a00218.html">range_type</a>;
00392     <span class="keyword">typedef</span> <a class="code" href="a00218.html">internal::hash_map_range&lt;const_iterator&gt;</a> <a class="code" href="a00218.html">const_range_type</a>;
00393     <span class="keyword">typedef</span> A allocator_type;
00394 
<a name="l00396"></a><a class="code" href="a00198.html">00396</a>     <span class="keyword">class </span><a class="code" href="a00198.html">const_accessor</a> {
00397         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00196.html">concurrent_hash_map</a>&lt;Key,T,HashCompare,A&gt;;
00398         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00197.html">accessor</a>;
00399         <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="a00197.html">accessor</a>&amp; ) <span class="keyword">const</span>; <span class="comment">// Deny access</span>
00400         <a class="code" href="a00198.html">const_accessor</a>( <span class="keyword">const</span> <a class="code" href="a00197.html">accessor</a>&amp; );       <span class="comment">// Deny access</span>
00401     <span class="keyword">public</span>:
<a name="l00403"></a><a class="code" href="a00198.html#w0">00403</a>         <span class="keyword">typedef</span> <span class="keyword">const</span> std::pair&lt;const Key,T&gt; value_type;
00404 
<a name="l00406"></a><a class="code" href="a00198.html#a0">00406</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> !my_node;}
00407 
<a name="l00409"></a><a class="code" href="a00198.html#a1">00409</a>         <span class="keywordtype">void</span> <a class="code" href="a00308.html#a55a2">release</a>() {
00410             <span class="keywordflow">if</span>( my_node ) {
00411                 my_lock.release();
00412                 my_node = NULL;
00413             }
00414         }
00415 
<a name="l00417"></a><a class="code" href="a00198.html#a2">00417</a>         const_reference operator*()<span class="keyword"> const </span>{
00418             __TBB_ASSERT( my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00419             <span class="keywordflow">return</span> my_node-&gt;item;
00420         }
00421 
<a name="l00423"></a><a class="code" href="a00198.html#a3">00423</a>         const_pointer operator-&gt;()<span class="keyword"> const </span>{
00424             <span class="keywordflow">return</span> &amp;operator*();
00425         }
00426 
<a name="l00428"></a><a class="code" href="a00198.html#a4">00428</a>         <a class="code" href="a00198.html">const_accessor</a>() : my_node(NULL) {}
00429 
<a name="l00431"></a><a class="code" href="a00198.html#a5">00431</a>         ~<a class="code" href="a00198.html">const_accessor</a>() {
00432             my_node = NULL; <span class="comment">// my_lock.release() is called in scoped_lock destructor</span>
00433         }
00434     <span class="keyword">private</span>:
00435         node* my_node;
00436         node_mutex_t::scoped_lock my_lock;
00437         hashcode_t my_hash;
00438     };
00439 
<a name="l00441"></a><a class="code" href="a00197.html">00441</a>     <span class="keyword">class </span><a class="code" href="a00197.html">accessor</a>: <span class="keyword">public</span> <a class="code" href="a00198.html">const_accessor</a> {
00442     <span class="keyword">public</span>:
<a name="l00444"></a><a class="code" href="a00197.html#w0">00444</a>         <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00445 
<a name="l00447"></a><a class="code" href="a00197.html#a0">00447</a>         reference operator*()<span class="keyword"> const </span>{
00448             __TBB_ASSERT( this-&gt;my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00449             <span class="keywordflow">return</span> this-&gt;my_node-&gt;item;
00450         }
00451 
<a name="l00453"></a><a class="code" href="a00197.html#a1">00453</a>         pointer operator-&gt;()<span class="keyword"> const </span>{
00454             <span class="keywordflow">return</span> &amp;operator*();
00455         }       
00456     };
00457 
<a name="l00459"></a><a class="code" href="a00196.html#a0">00459</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>(<span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00460         : my_allocator(a)
00461 
00462     {
00463         initialize();
00464     }
00465 
<a name="l00467"></a><a class="code" href="a00196.html#a1">00467</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>( <span class="keyword">const</span> <a class="code" href="a00196.html">concurrent_hash_map</a>&amp; table, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00468         : my_allocator(a)
00469     {
00470         initialize();
00471         internal_copy(table);
00472     }
00473 
00475     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00476"></a><a class="code" href="a00196.html#a2">00476</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>(I first, I last, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00477         : my_allocator(a)
00478     {
00479         initialize();
00480         internal_copy(first, last);
00481     }
00482 
<a name="l00484"></a><a class="code" href="a00196.html#a3">00484</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00196.html">concurrent_hash_map</a>&amp; table ) {
00485         <span class="keywordflow">if</span>( <span class="keyword">this</span>!=&amp;table ) {
00486             clear();
00487             internal_copy(table);
00488         } 
00489         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00490     }
00491 
00492 
00494     <span class="keywordtype">void</span> clear();
00495 
00497     ~<a class="code" href="a00196.html">concurrent_hash_map</a>();
00498 
00499     <span class="comment">//------------------------------------------------------------------------</span>
00500     <span class="comment">// Parallel algorithm support</span>
00501     <span class="comment">//------------------------------------------------------------------------</span>
00502     range_type range( size_type grainsize=1 ) {
00503         <span class="keywordflow">return</span> range_type( begin(), end(), grainsize );
00504     }
00505     const_range_type range( size_type grainsize=1 )<span class="keyword"> const </span>{
00506         <span class="keywordflow">return</span> const_range_type( begin(), end(), grainsize );
00507     }
00508 
00509     <span class="comment">//------------------------------------------------------------------------</span>
00510     <span class="comment">// STL support - not thread-safe methods</span>
00511     <span class="comment">//------------------------------------------------------------------------</span>
00512     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,0);}
00513     iterator end() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,n_segment);}
00514     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,0);}
00515     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,n_segment);}
00516     std::pair&lt;iterator, iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key ) { <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00517     std::pair&lt;const_iterator, const_iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00518     
00520 
00522     size_type size() <span class="keyword">const</span>;
00523 
00525     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
00526 
<a name="l00528"></a><a class="code" href="a00196.html#a16">00528</a>     size_type max_size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> (~size_type(0))/<span class="keyword">sizeof</span>(node);}
00529 
<a name="l00531"></a><a class="code" href="a00196.html#a17">00531</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00532 
00534     <span class="keywordtype">void</span> swap(<a class="code" href="a00196.html">concurrent_hash_map</a> &amp;table);
00535 
00536     <span class="comment">//------------------------------------------------------------------------</span>
00537     <span class="comment">// concurrent map operations</span>
00538     <span class="comment">//------------------------------------------------------------------------</span>
00539 
<a name="l00541"></a><a class="code" href="a00196.html#a19">00541</a>     size_type count( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00542         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;<a class="code" href="a00196.html#d7">lookup</a>&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(NULL, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00543     }
00544 
00546 
<a name="l00547"></a><a class="code" href="a00196.html#a20">00547</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00198.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00548         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;<a class="code" href="a00196.html#d7">lookup</a>&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00549     }
00550 
00552 
<a name="l00553"></a><a class="code" href="a00196.html#a21">00553</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00197.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00554         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00555     }
00556         
00558 
<a name="l00559"></a><a class="code" href="a00196.html#a22">00559</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00198.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00560         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00561     }
00562 
00564 
<a name="l00565"></a><a class="code" href="a00196.html#a23">00565</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00197.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00566         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00567     }
00568 
00570 
<a name="l00571"></a><a class="code" href="a00196.html#a24">00571</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00198.html">const_accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00572         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00573     }
00574 
00576 
<a name="l00577"></a><a class="code" href="a00196.html#a25">00577</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00197.html">accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00578         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">true</span>, &amp;value.second );
00579     }
00580 
00582 
<a name="l00583"></a><a class="code" href="a00196.html#a26">00583</a>     <span class="keywordtype">bool</span> insert( <span class="keyword">const</span> value_type&amp; value ) {
00584         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(NULL, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00585     }
00586 
00588     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00589"></a><a class="code" href="a00196.html#a27">00589</a>     <span class="keywordtype">void</span> insert(I first, I last) {
00590         <span class="keywordflow">for</span>(; first != last; ++first)
00591             insert( *first );
00592     }
00593 
00595 
00596     <span class="keywordtype">bool</span> erase( <span class="keyword">const</span> Key&amp; key );
00597 
00599 
<a name="l00600"></a><a class="code" href="a00196.html#a29">00600</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00198.html">const_accessor</a>&amp; item_accessor ) {
00601         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">true</span> );
00602     }
00603 
00605 
<a name="l00606"></a><a class="code" href="a00196.html#a30">00606</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00197.html">accessor</a>&amp; item_accessor ) {
00607         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">false</span> );
00608     }
00609 
00610 <span class="keyword">private</span>:
00612     <span class="keyword">struct </span>node {
00614         node* next;
00615         node_mutex_t <a class="code" href="a00221.html">mutex</a>;
00616         value_type item;
00617         node( <span class="keyword">const</span> Key&amp; key ) : item(key, T()) {}
00618         node( <span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T&amp; t ) : item(key, t) {}
00619         <span class="comment">// exception-safe allocation, see C++ Standard 2003, clause 5.3.4p17</span>
00620         <span class="keywordtype">void</span>* operator new( size_t size, node_allocator_type&amp; a ) {
00621             <span class="keywordtype">void</span> *ptr = a.allocate(1);
00622             <span class="keywordflow">if</span>(!ptr) <span class="keywordflow">throw</span> std::bad_alloc();
00623             <span class="keywordflow">return</span> ptr;
00624         }
00625         <span class="comment">// match placement-new form above to be called if exception thrown in constructor</span>
00626         <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* ptr, node_allocator_type&amp; a ) {<span class="keywordflow">return</span> a.deallocate(static_cast&lt;node*&gt;(ptr),1); }
00627     };
00628 
00629     <span class="keyword">struct </span>chain;
00630     <span class="keyword">friend</span> <span class="keyword">struct </span>chain;
00631 
00633 
00634     <span class="keyword">struct </span>chain {
00635         <span class="keywordtype">void</span> push_front( node&amp; b ) {
00636             b.next = node_list;
00637             node_list = &amp;b;
00638         }
00639         chain_mutex_t mutex;
00640         node* node_list;
00641     };
00642 
00643     <span class="keyword">struct </span>segment;
00644     <span class="keyword">friend</span> <span class="keyword">struct </span>segment;
00645 
00647 
00649     <span class="keyword">struct </span>segment: internal::hash_map_segment_base {
00650 <span class="preprocessor">#if TBB_DO_ASSERT</span>
00651 <span class="preprocessor"></span>        ~segment() {
00652             __TBB_ASSERT( !my_array, <span class="stringliteral">"should have been cleared earlier"</span> );
00653         }
00654 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_ASSERT */</span>
00655 
00656         <span class="comment">// Pointer to array of chains</span>
00657         chain* my_array;
00658 
00659         <span class="comment">// Get chain in this segment that corresponds to given hash code.</span>
00660         chain&amp; get_chain( hashcode_t hashcode, size_t n_segment_bits ) {
00661             <span class="keywordflow">return</span> my_array[(hashcode&gt;&gt;n_segment_bits)&amp;(my_physical_size-1)];
00662         }
00663      
00665 
00667         <span class="keywordtype">void</span> allocate_array( size_t new_size ) {
00668             size_t n=(internal::NFS_GetLineSize()+<span class="keyword">sizeof</span>(chain)-1)/<span class="keyword">sizeof</span>(chain);
00669             __TBB_ASSERT((n&amp;(n-1))==0, NULL);
00670             <span class="keywordflow">while</span>( n&lt;new_size ) n&lt;&lt;=1;
00671             chain* array = cache_aligned_allocator&lt;chain&gt;().allocate( n );
00672             <span class="comment">// storing earlier might help overcome false positives of in deducing "bool grow" in concurrent threads</span>
00673             __TBB_store_with_release(my_physical_size, n);
00674             std::memset( array, 0, n*<span class="keyword">sizeof</span>(chain) );
00675             my_array = array;
00676         }
00677     };
00678 
00679     segment&amp; get_segment( hashcode_t hashcode ) {
00680         <span class="keywordflow">return</span> my_segment[hashcode&amp;(n_segment-1)];
00681     }
00682 
00683     node_allocator_type my_allocator;
00684 
00685     HashCompare my_hash_compare;
00686 
00687     segment* my_segment;
00688 
00689     node* create_node(<span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T* t) {
00690         <span class="comment">// exception-safe allocation and construction</span>
00691         <span class="keywordflow">if</span>(t) <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key, *t);
00692         <span class="keywordflow">else</span>  <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key);
00693     }
00694 
00695     <span class="keywordtype">void</span> delete_node(node* b) {
00696         my_allocator.destroy(b);
00697         my_allocator.deallocate(b, 1);
00698     }
00699 
00700     node* search_list( <span class="keyword">const</span> Key&amp; key, chain&amp; c )<span class="keyword"> const </span>{
00701         node* b = c.node_list;
00702         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first) )
00703             b = b-&gt;next;
00704         <span class="keywordflow">return</span> b;
00705     }
00707     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00708     std::pair&lt;I, I&gt; internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end ) <span class="keyword">const</span>;
00709 
00711     <span class="keywordtype">bool</span> exclude( const_accessor&amp; item_accessor, <span class="keywordtype">bool</span> readonly );
00712 
00714     <span class="keywordtype">void</span> grow_segment( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s );
00715 
00717     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00718     <span class="keywordtype">bool</span> lookup( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t );
00719 
00721     <span class="keywordtype">void</span> initialize() {
00722         my_segment = cache_aligned_allocator&lt;segment&gt;().allocate(n_segment);
00723         std::memset( my_segment, 0, <span class="keyword">sizeof</span>(segment)*n_segment );
00724      }
00725 
00727     <span class="keywordtype">void</span> internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source );
00728 
00729     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00730     <span class="keywordtype">void</span> internal_copy(I first, I last);
00731 };
00732 
00733 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00734"></a><a class="code" href="a00196.html#a5">00734</a> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::~concurrent_hash_map</a>() {
00735     <a class="code" href="a00196.html#a4">clear</a>();
00736     <a class="code" href="a00193.html">cache_aligned_allocator&lt;segment&gt;</a>().deallocate( my_segment, n_segment );
00737 }
00738 
00739 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00740"></a><a class="code" href="a00196.html#a14">00740</a> <span class="keyword">typename</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a>::size_type <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::size</a>()<span class="keyword"> const </span>{
00741     size_type result = 0;
00742     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00743         result += my_segment[k].my_logical_size;
00744     <span class="keywordflow">return</span> result;
00745 }
00746 
00747 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00748"></a><a class="code" href="a00196.html#a15">00748</a> <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::empty</a>()<span class="keyword"> const </span>{
00749     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00750         <span class="keywordflow">if</span>( my_segment[k].my_logical_size )
00751             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00752     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00753 }
00754 
00755 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00756 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00757 <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::lookup</a>( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t ) {
00758     <span class="keywordflow">if</span>( result <span class="comment">/*&amp;&amp; result-&gt;my_node -- checked in release() */</span> )
00759         result-&gt;release();
00760     <span class="keyword">const</span> hashcode_t h = my_hash_compare.hash( key );
00761     segment&amp; s = get_segment(h);
00762 restart:
00763     <span class="keywordtype">bool</span> return_value = <span class="keyword">false</span>;
00764     <span class="comment">// first check in double-check sequence</span>
00765 <span class="preprocessor">#if TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT</span>
00766 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.internal_grow_predicate();
00767 <span class="preprocessor">#else</span>
00768 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.my_logical_size &gt;= s.my_physical_size
00769         &amp;&amp; s.my_physical_size &lt; max_physical_size; <span class="comment">// check whether there are free bits</span>
00770 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT */</span>
00771     segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span>grow );
00772     <span class="keywordflow">if</span>( grow ) { <span class="comment">// Load factor is too high  </span>
00773         grow_segment( segment_lock, s );
00774     }
00775     <span class="keywordflow">if</span>( !s.my_array ) {
00776         __TBB_ASSERT( !op_insert, NULL );
00777         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00778     }
00779     __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00780     chain&amp; c = s.get_chain( h, n_segment_bits );
00781     chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00782 
00783     node* b = search_list( key, c );
00784     <span class="keywordflow">if</span>( op_insert ) {
00785         <span class="keywordflow">if</span>( !b ) {
00786             b = create_node(key, t);
00787             <span class="comment">// Search failed</span>
00788             <span class="keywordflow">if</span>( !chain_lock.upgrade_to_writer() ) {
00789                 <span class="comment">// Rerun search_list, in case another thread inserted the item during the upgrade.</span>
00790                 node* b_temp = search_list( key, c );
00791                 <span class="keywordflow">if</span>( b_temp ) { <span class="comment">// unfortunately, it did</span>
00792                     chain_lock.downgrade_to_reader();
00793                     delete_node( b );
00794                     b = b_temp;
00795                     <span class="keywordflow">goto</span> done;
00796                 }
00797             }
00798             ++s.my_logical_size; <span class="comment">// we can't change it earlier due to correctness of size() and exception safety of equal()</span>
00799             return_value = <span class="keyword">true</span>;
00800             c.push_front( *b );
00801         }
00802     } <span class="keywordflow">else</span> { <span class="comment">// find or count</span>
00803         <span class="keywordflow">if</span>( !b )      <span class="keywordflow">return</span> <span class="keyword">false</span>;
00804         return_value = <span class="keyword">true</span>;
00805     }
00806 done:
00807     <span class="keywordflow">if</span>( !result ) <span class="keywordflow">return</span> return_value;
00808     <span class="keywordflow">if</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) ) {
00809         <span class="comment">// we are unlucky, prepare for longer wait</span>
00810         internal::AtomicBackoff trials;
00811         <span class="keywordflow">do</span> {
00812             <span class="keywordflow">if</span>( !trials.bounded_pause() ) {
00813                 <span class="comment">// the wait takes really long, restart the operation</span>
00814                 chain_lock.release(); segment_lock.release();
00815                 __TBB_Yield();
00816                 <span class="keywordflow">goto</span> restart;
00817             }
00818         } <span class="keywordflow">while</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) );
00819     }
00820     result-&gt;my_node = b;
00821     result-&gt;my_hash = h;
00822     <span class="keywordflow">return</span> return_value;
00823 }
00824 
00825 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00826 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00827 std::pair&lt;I, I&gt; concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end )<span class="keyword"> const </span>{
00828     <a class="code" href="a00217.html#w3">hashcode_t</a> h = my_hash_compare.hash( key );
00829     size_t segment_index = h&amp;(<a class="code" href="a00217.html#s1">n_segment</a>-1);
00830     segment&amp; s = my_segment[segment_index ];
00831     size_t chain_index = (h&gt;&gt;n_segment_bits)&amp;(s.my_physical_size-1);
00832     <span class="keywordflow">if</span>( !s.my_array )
00833         <span class="keywordflow">return</span> std::make_pair(end, end);
00834     chain&amp; c = s.my_array[chain_index];
00835     node* b = search_list( key, c );
00836     <span class="keywordflow">if</span>( !b )
00837         <span class="keywordflow">return</span> std::make_pair(end, end);
00838     iterator lower(*<span class="keyword">this</span>, segment_index, chain_index, b), upper(lower);
00839     <span class="keywordflow">return</span> std::make_pair(lower, ++upper);
00840 }
00841 
00842 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00843"></a><a class="code" href="a00196.html#a28">00843</a> <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::erase</a>( <span class="keyword">const</span> Key &amp;key ) {
00844     hashcode_t h = my_hash_compare.hash( key );
00845     segment&amp; s = get_segment( h );
00846     node* b=NULL; <span class="comment">// explicitly initialized to prevent compiler warnings</span>
00847     {
00848         <span class="keywordtype">bool</span> chain_locked_for_write = <span class="keyword">false</span>;
00849         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00850         <span class="keywordflow">if</span>( !s.my_array ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00851         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00852         chain&amp; c = s.get_chain( h, n_segment_bits );
00853         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00854     search:
00855         node** p = &amp;c.node_list;
00856         b = *p;
00857         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first ) ) {
00858             p = &amp;b-&gt;next;
00859             b = *p;
00860         }
00861         <span class="keywordflow">if</span>( !b ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00862         <span class="keywordflow">if</span>( !chain_locked_for_write &amp;&amp; !chain_lock.upgrade_to_writer() ) {
00863             chain_locked_for_write = <span class="keyword">true</span>;
00864             <span class="keywordflow">goto</span> search;
00865         }
00866         *p = b-&gt;next;
00867         --s.my_logical_size;
00868     }
00869     {
00870         node_mutex_t::scoped_lock item_locker( b-&gt;mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00871     }
00872     <span class="comment">// note: there should be no threads pretending to acquire this mutex again, do not try to upgrade const_accessor!</span>
00873     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00874     <span class="keywordflow">return</span> <span class="keyword">true</span>;        
00875 }
00876 
00877 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00878 <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::exclude</a>( const_accessor &amp;item_accessor, <span class="keywordtype">bool</span> readonly ) {
00879     __TBB_ASSERT( item_accessor.my_node, NULL );
00880     <span class="keyword">const</span> hashcode_t h = item_accessor.my_hash;
00881     node *<span class="keyword">const</span> b = item_accessor.my_node;
00882     item_accessor.my_node = NULL; <span class="comment">// we ought release accessor anyway</span>
00883     segment&amp; s = get_segment( h );
00884     {
00885         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00886         __TBB_ASSERT( s.my_array, NULL );
00887         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00888         chain&amp; c = s.get_chain( h, n_segment_bits );
00889         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00890         node** p = &amp;c.node_list;
00891         <span class="keywordflow">while</span>( *p &amp;&amp; *p != b )
00892             p = &amp;(*p)-&gt;next;
00893         <span class="keywordflow">if</span>( !*p ) { <span class="comment">// someone else was the first</span>
00894             item_accessor.my_lock.release();
00895             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00896         }
00897         __TBB_ASSERT( *p == b, NULL );
00898         *p = b-&gt;next;
00899         --s.my_logical_size;
00900     }
00901     <span class="keywordflow">if</span>( readonly ) <span class="comment">// need to get exclusive lock</span>
00902         item_accessor.my_lock.upgrade_to_writer(); <span class="comment">// return value means nothing here</span>
00903     item_accessor.my_lock.release();
00904     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00905     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00906 }
00907 
00908 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00909"></a><a class="code" href="a00196.html#a18">00909</a> <span class="keywordtype">void</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::swap</a>(<a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a> &amp;table) {
00910     std::swap(this-&gt;my_allocator, table.<a class="code" href="a00196.html#r0">my_allocator</a>);
00911     std::swap(this-&gt;my_hash_compare, table.<a class="code" href="a00196.html#r1">my_hash_compare</a>);
00912     std::swap(this-&gt;my_segment, table.<a class="code" href="a00196.html#r2">my_segment</a>);
00913 }
00914 
00915 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00916"></a><a class="code" href="a00196.html#a4">00916</a> <span class="keywordtype">void</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::clear</a>() {
00917 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00918 <span class="preprocessor"></span>    size_t total_physical_size = 0, min_physical_size = size_t(-1L), max_physical_size = 0; <span class="comment">//&lt; usage statistics</span>
00919     <span class="keyword">static</span> <span class="keywordtype">bool</span> reported = <span class="keyword">false</span>;
00920 <span class="preprocessor">#endif</span>
00921 <span class="preprocessor"></span>    <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00922         segment&amp; s = my_segment[i];
00923         size_t n = s.my_physical_size;
00924         <span class="keywordflow">if</span>( chain* array = s.my_array ) {
00925             s.my_array = NULL;
00926             s.my_physical_size = 0;
00927             s.my_logical_size = 0;
00928             <span class="keywordflow">for</span>( size_t j=0; j&lt;n; ++j ) {
00929                 <span class="keywordflow">while</span>( node* b = array[j].node_list ) {
00930                     array[j].node_list = b-&gt;next;
00931                     delete_node(b);
00932                 }
00933             }
00934             <a class="code" href="a00193.html">cache_aligned_allocator&lt;chain&gt;</a>().deallocate( array, n );
00935         }
00936 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00937 <span class="preprocessor"></span>        total_physical_size += n;
00938         <span class="keywordflow">if</span>(min_physical_size &gt; n) min_physical_size = n;
00939         <span class="keywordflow">if</span>(max_physical_size &lt; n) max_physical_size = n;
00940     }
00941     <span class="keywordflow">if</span>( !reported
00942         &amp;&amp; ( (total_physical_size &gt;= n_segment*48 &amp;&amp; min_physical_size &lt; total_physical_size/n_segment/2)
00943          || (total_physical_size &gt;= n_segment*128 &amp;&amp; max_physical_size &gt; total_physical_size/n_segment*2) ) )
00944     {
00945         reported = <span class="keyword">true</span>;
00946         internal::runtime_warning(
00947             <span class="stringliteral">"Performance is not optimal because the hash function produces bad randomness in lower bits in %s"</span>,
00948             <span class="keyword">typeid</span>(*this).name() );
00949 <span class="preprocessor">#endif</span>
00950 <span class="preprocessor"></span>    }
00951 }
00952 
00953 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00954 <span class="keywordtype">void</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::grow_segment</a>( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s ) {
00955     <span class="comment">// Following is second check in a double-check.</span>
00956     <span class="keywordflow">if</span>( s.my_logical_size &gt;= s.my_physical_size ) {
00957         chain* old_array = s.my_array;
00958         size_t old_size = s.my_physical_size;
00959         s.allocate_array( s.my_logical_size+1 );
00960         <span class="keywordflow">for</span>( size_t k=0; k&lt;old_size; ++k )
00961             <span class="keywordflow">while</span>( node* b = old_array[k].node_list ) {
00962                 old_array[k].node_list = b-&gt;next;
00963                 hashcode_t h = my_hash_compare.hash( b-&gt;item.first );
00964                 __TBB_ASSERT( &amp;get_segment(h)==&amp;s, <span class="stringliteral">"hash function changed?"</span> );
00965                 s.get_chain(h,n_segment_bits).push_front(*b);
00966             }
00967         cache_aligned_allocator&lt;chain&gt;().deallocate( old_array, old_size );
00968     }
00969     segment_lock.downgrade_to_reader();
00970 }
00971 
00972 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00973 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source ) {
00974     <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00975         segment&amp; s = source.my_segment[i];
00976         __TBB_ASSERT( !my_segment[i].my_array, <span class="stringliteral">"caller should have cleared"</span> );
00977         <span class="keywordflow">if</span>( s.my_logical_size ) {
00978             segment&amp; d = my_segment[i];
00979             d.allocate_array( s.my_logical_size );
00980             d.my_logical_size = s.my_logical_size;
00981             size_t s_size = s.my_physical_size;
00982             chain* s_array = s.my_array;
00983             chain* d_array = d.my_array;
00984             <span class="keywordflow">for</span>( size_t k=0; k&lt;s_size; ++k )
00985                 <span class="keywordflow">for</span>( node* b = s_array[k].node_list; b; b=b-&gt;next ) {
00986                     __TBB_ASSERT( &amp;get_segment(my_hash_compare.hash( b-&gt;item.first ))==&amp;d, <span class="stringliteral">"hash function changed?"</span> );
00987                     node* b_new = create_node(b-&gt;item.first, &amp;b-&gt;item.second);
00988                     d_array[k].push_front(*b_new); <span class="comment">// hashcode is the same and segment and my_physical sizes are the same</span>
00989                 }
00990         }
00991     }
00992 }
00993 
00994 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00995 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00996 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy(I first, I last) {
00997     <span class="keywordflow">for</span>(; first != last; ++first)
00998         <a class="code" href="a00196.html#a22">insert</a>( *first );
00999 }
01000 
01001 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
01002 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b) {
01003     <span class="keywordflow">if</span>(a.size() != b.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01004     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt;::const_iterator i(a.begin()), i_end(a.end());
01005     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt;::const_iterator j, j_end(b.end());
01006     <span class="keywordflow">for</span>(; i != i_end; ++i) {
01007         j = b.equal_range(i-&gt;first).first;
01008         <span class="keywordflow">if</span>( j == j_end || !(i-&gt;second == j-&gt;second) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01009     }
01010     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01011 }
01012 
01013 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
01014 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b)
01015 {    <span class="keywordflow">return</span> !(a == b); }
01016 
01017 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
01018 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;a, concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;b)
01019 {    a.swap( b ); }
01020 
01021 } <span class="comment">// namespace tbb</span>
01022 
01023 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_hash_map_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
