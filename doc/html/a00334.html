<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_queue.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_queue_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_queue_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "tbb_stddef.h"</span>
00025 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00026 <span class="preprocessor">#include &lt;iterator&gt;</span>
00027 <span class="preprocessor">#include &lt;new&gt;</span>
00028 
00029 <span class="keyword">namespace </span>tbb {
00030 
00031 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A = cache_aligned_allocator&lt;T&gt; &gt; 
00032 <span class="keyword">class </span>concurrent_queue;
00033 
00035 <span class="keyword">namespace </span>internal {
00036 
00037 <span class="keyword">class </span>concurrent_queue_rep;
00038 <span class="keyword">class </span>concurrent_queue_iterator_rep;
00039 <span class="keyword">class </span>concurrent_queue_iterator_base_v3;
00040 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">class </span>concurrent_queue_iterator;
00041 
00043 
<a name="l00045"></a><a class="code" href="a00209.html">00045</a> <span class="keyword">class </span><a class="code" href="a00209.html">concurrent_queue_base_v3</a>: <a class="code" href="a00234.html">no_copy</a> {
00047     concurrent_queue_rep* my_rep;
00048 
00049     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_rep;
00050     <span class="keyword">friend</span> <span class="keyword">struct </span>micro_queue;
00051     <span class="keyword">friend</span> <span class="keyword">class </span>micro_queue_pop_finalizer;
00052     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_iterator_rep;
00053     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>;
00054 <span class="keyword">protected</span>:
<a name="l00056"></a><a class="code" href="a00210.html">00056</a>     <span class="keyword">struct </span><a class="code" href="a00210.html">page</a> {
00057         <a class="code" href="a00210.html">page</a>* next;
00058         <a class="code" href="a00323.html#a21">uintptr</a> mask; 
00059     };
00060 
<a name="l00062"></a><a class="code" href="a00209.html#p0">00062</a>     ptrdiff_t my_capacity;
00063    
<a name="l00065"></a><a class="code" href="a00209.html#p1">00065</a>     size_t items_per_page;
00066 
<a name="l00068"></a><a class="code" href="a00209.html#p2">00068</a>     size_t item_size;
00069 
00070 <span class="keyword">private</span>:
00071     <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( <a class="code" href="a00210.html">page</a>&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) = 0;
00072     <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, <a class="code" href="a00210.html">page</a>&amp; src, size_t index ) = 0;
00073 <span class="keyword">protected</span>:
00074     __TBB_EXPORTED_METHOD <a class="code" href="a00209.html">concurrent_queue_base_v3</a>( size_t item_size );
00075     <span class="keyword">virtual</span> __TBB_EXPORTED_METHOD ~<a class="code" href="a00209.html">concurrent_queue_base_v3</a>();
00076 
00078     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_push( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00079 
00081     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_pop( <span class="keywordtype">void</span>* dst );
00082 
00084     <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_push_if_not_full( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00085 
00087 
00088     <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_pop_if_present( <span class="keywordtype">void</span>* dst );
00089 
00091     ptrdiff_t __TBB_EXPORTED_METHOD internal_size() <span class="keyword">const</span>;
00092 
00094     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_set_capacity( ptrdiff_t capacity, size_t element_size );
00095 
00097     <span class="keyword">virtual</span> <a class="code" href="a00210.html">page</a> *allocate_page() = 0;
00098 
00100     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( <a class="code" href="a00210.html">page</a> *p ) = 0;
00101 
00103     <span class="comment">/* note that the name may be misleading, but it remains so due to a historical accident. */</span>
00104     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_finish_clear() ;
00105 
00107     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_throw_exception() <span class="keyword">const</span>;
00108 };
00109 
00110 <span class="keyword">typedef</span> <a class="code" href="a00209.html">concurrent_queue_base_v3</a> <a class="code" href="a00209.html">concurrent_queue_base</a> ;
00111 
00113 
<a name="l00114"></a><a class="code" href="a00212.html">00114</a> <span class="keyword">class </span><a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a> {
00116 
00117     concurrent_queue_iterator_rep* my_rep;
00118 
00119     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00120     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="a00211.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00211.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00121 
00122     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00123     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> <a class="code" href="a00211.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00211.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00124 <span class="keyword">protected</span>:
<a name="l00126"></a><a class="code" href="a00212.html#p0">00126</a>     <span class="keyword">mutable</span> <span class="keywordtype">void</span>* my_item;
00127 
<a name="l00129"></a><a class="code" href="a00212.html#b0">00129</a>     <a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>() : my_rep(NULL), my_item(NULL) {}
00130 
<a name="l00132"></a><a class="code" href="a00212.html#b1">00132</a>     <a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> <a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>&amp; i ) : my_rep(NULL), my_item(NULL) {
00133         assign(i);
00134     }
00135 
00137     __TBB_EXPORTED_METHOD <a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue );
00138 
00140     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD assign( <span class="keyword">const</span> <a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>&amp; i );
00141 
00143     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD advance();
00144 
00146     __TBB_EXPORTED_METHOD ~<a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>();
00147 };
00148 
00149 <span class="keyword">typedef</span> concurrent_queue_iterator_base_v3 concurrent_queue_iterator_base;
00150 
00152 
00154 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
<a name="l00155"></a><a class="code" href="a00211.html">00155</a> <span class="keyword">class </span><a class="code" href="a00211.html">concurrent_queue_iterator</a>: <span class="keyword">public</span> concurrent_queue_iterator_base,
00156         <span class="keyword">public</span> std::iterator&lt;std::forward_iterator_tag,Value&gt; {
00157 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00158 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
00159     <span class="keyword">friend</span> class ::tbb::concurrent_queue;
00160 <span class="preprocessor">#else</span>
00161 <span class="preprocessor"></span><span class="keyword">public</span>: <span class="comment">// workaround for MSVC</span>
00162 <span class="preprocessor">#endif </span>
00163 <span class="preprocessor"></span>
<a name="l00164"></a><a class="code" href="a00211.html#a0">00164</a>     <a class="code" href="a00211.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue ) :
00165         <a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>(queue)
00166     {
00167     }
00168 <span class="keyword">public</span>:
00169     <a class="code" href="a00211.html">concurrent_queue_iterator</a>() {}
00170 
<a name="l00173"></a><a class="code" href="a00211.html#a2">00173</a>     <a class="code" href="a00211.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> <a class="code" href="a00211.html">concurrent_queue_iterator&lt;Container,typename Container::value_type&gt;</a>&amp; other ) :
00174         <a class="code" href="a00212.html">concurrent_queue_iterator_base_v3</a>(other)
00175     {}
00176 
<a name="l00178"></a><a class="code" href="a00211.html#a3">00178</a>     <a class="code" href="a00211.html">concurrent_queue_iterator</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00211.html">concurrent_queue_iterator</a>&amp; other ) {
00179         assign(other);
00180         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00181     }
00182 
<a name="l00184"></a><a class="code" href="a00211.html#a4">00184</a>     Value&amp; operator*()<span class="keyword"> const </span>{
00185         <span class="keywordflow">return</span> *static_cast&lt;Value*&gt;(my_item);
00186     }
00187 
00188     Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00189 
<a name="l00191"></a><a class="code" href="a00211.html#a6">00191</a>     <a class="code" href="a00211.html">concurrent_queue_iterator</a>&amp; operator++() {
00192         advance();
00193         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00194     }
00195 
<a name="l00197"></a><a class="code" href="a00211.html#a7">00197</a>     Value* operator++(<span class="keywordtype">int</span>) {
00198         Value* result = &amp;operator*();
00199         operator++();
00200         <span class="keywordflow">return</span> result;
00201     }
00202 }; <span class="comment">// concurrent_queue_iterator</span>
00203 
00204 
00205 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00206 <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00207     <span class="keywordflow">return</span> i.<a class="code" href="a00212.html#p0">my_item</a>==j.<a class="code" href="a00212.html#p0">my_item</a>;
00208 }
00209 
00210 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00211 <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00212     <span class="keywordflow">return</span> i.<a class="code" href="a00212.html#p0">my_item</a>!=j.<a class="code" href="a00212.html#p0">my_item</a>;
00213 }
00214 
00215 } <span class="comment">// namespace internal;</span>
00216 
00218 
00220 
00223 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00224"></a><a class="code" href="a00208.html">00224</a> <span class="keyword">class </span><a class="code" href="a00208.html">concurrent_queue</a>: <span class="keyword">public</span> internal::concurrent_queue_base_v3 {
00225     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00211.html">internal::concurrent_queue_iterator</a>;
00226 
00228     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;char&gt;::other page_allocator_type;
00229     page_allocator_type my_allocator;
00230 
00232     <span class="keyword">class </span>destroyer {
00233         T&amp; my_value;
00234     <span class="keyword">public</span>:
00235         destroyer( T&amp; value ) : my_value(value) {}
00236         ~destroyer() {my_value.~T();}          
00237     };
00238 
00239     T&amp; get_ref( page&amp; page, size_t index ) {
00240         __TBB_ASSERT( index&lt;items_per_page, NULL );
00241         <span class="keywordflow">return</span> static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;page+1))[index];
00242     }
00243 
00244     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( page&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) {
00245         <span class="keyword">new</span>( &amp;get_ref(dst,index) ) T(*static_cast&lt;const T*&gt;(src)); 
00246     }
00247 
00248     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, page&amp; src, size_t index ) {
00249         T&amp; from = get_ref(src,index);
00250         destroyer d(from);
00251         *static_cast&lt;T*&gt;(dst) = from;
00252     }
00253 
00254     <span class="comment">/*overide*/</span> <span class="keyword">virtual</span> page *allocate_page() {
00255         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00256         page *p = reinterpret_cast&lt;page*&gt;(my_allocator.allocate( n ));
00257         <span class="keywordflow">if</span>( !p ) internal_throw_exception(); 
00258         <span class="keywordflow">return</span> p;
00259     }
00260     
00261     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( page *p ) {
00262         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00263         my_allocator.deallocate( reinterpret_cast&lt;char*&gt;(p), n );
00264     }
00265 
00266 <span class="keyword">public</span>:
<a name="l00268"></a><a class="code" href="a00208.html#w0">00268</a>     <span class="keyword">typedef</span> T value_type;
00269 
<a name="l00271"></a><a class="code" href="a00208.html#w1">00271</a>     <span class="keyword">typedef</span> A allocator_type;
00272 
<a name="l00274"></a><a class="code" href="a00208.html#w2">00274</a>     <span class="keyword">typedef</span> T&amp; reference;
00275 
<a name="l00277"></a><a class="code" href="a00208.html#w3">00277</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;
00278 
00280 
<a name="l00282"></a><a class="code" href="a00208.html#w4">00282</a>     <span class="keyword">typedef</span> std::ptrdiff_t size_type;
00283 
<a name="l00285"></a><a class="code" href="a00208.html#w5">00285</a>     <span class="keyword">typedef</span> std::ptrdiff_t difference_type;
00286 
<a name="l00288"></a><a class="code" href="a00208.html#a0">00288</a>     <a class="code" href="a00208.html">concurrent_queue</a>(<span class="keyword">const</span> allocator_type  &amp;a = allocator_type()) : 
00289         concurrent_queue_base_v3( sizeof(T) )
00290             , my_allocator( a )
00291     {
00292     }
00293 
00295     ~<a class="code" href="a00208.html">concurrent_queue</a>();
00296 
<a name="l00298"></a><a class="code" href="a00208.html#a2">00298</a>     <span class="keywordtype">void</span> push( <span class="keyword">const</span> T&amp; source ) {
00299         internal_push( &amp;source );
00300     }
00301 
00303 
<a name="l00304"></a><a class="code" href="a00208.html#a3">00304</a>     <span class="keywordtype">void</span> pop( T&amp; destination ) {
00305         internal_pop( &amp;destination );
00306     }
00307 
00309 
<a name="l00311"></a><a class="code" href="a00208.html#a4">00311</a>     <span class="keywordtype">bool</span> push_if_not_full( <span class="keyword">const</span> T&amp; source ) {
00312         <span class="keywordflow">return</span> internal_push_if_not_full( &amp;source );
00313     }
00314 
00316 
<a name="l00318"></a><a class="code" href="a00208.html#a5">00318</a>     <span class="keywordtype">bool</span> pop_if_present( T&amp; destination ) {
00319         <span class="keywordflow">return</span> internal_pop_if_present( &amp;destination );
00320     }
00321 
00323 
<a name="l00326"></a><a class="code" href="a00208.html#a6">00326</a>     size_type size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> internal_size();}
00327 
<a name="l00329"></a><a class="code" href="a00208.html#a7">00329</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> size()&lt;=0;}
00330 
<a name="l00332"></a><a class="code" href="a00208.html#a8">00332</a>     size_type capacity()<span class="keyword"> const </span>{
00333         <span class="keywordflow">return</span> my_capacity;
00334     }
00335 
00337 
<a name="l00339"></a><a class="code" href="a00208.html#a9">00339</a>     <span class="keywordtype">void</span> set_capacity( size_type capacity ) {
00340         internal_set_capacity( capacity, <span class="keyword">sizeof</span>(T) );
00341     }
00342 
<a name="l00344"></a><a class="code" href="a00208.html#a10">00344</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00345 
00347     <span class="keywordtype">void</span> clear() ;
00348 
00349     <span class="keyword">typedef</span> <a class="code" href="a00211.html">internal::concurrent_queue_iterator&lt;concurrent_queue,T&gt;</a> iterator;
00350     <span class="keyword">typedef</span> <a class="code" href="a00211.html">internal::concurrent_queue_iterator&lt;concurrent_queue,const T&gt;</a> const_iterator;
00351 
00352     <span class="comment">//------------------------------------------------------------------------</span>
00353     <span class="comment">// The iterators are intended only for debugging.  They are slow and not thread safe.</span>
00354     <span class="comment">//------------------------------------------------------------------------</span>
00355     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>);}
00356     iterator end() {<span class="keywordflow">return</span> iterator();}
00357     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>);}
00358     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator();}
00359     
00360 }; 
00361 
00362 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00363"></a><a class="code" href="a00208.html#a1">00363</a> <a class="code" href="a00208.html">concurrent_queue&lt;T,A&gt;::~concurrent_queue</a>() {
00364     <a class="code" href="a00208.html#a11">clear</a>();
00365     <a class="code" href="a00209.html#b10">internal_finish_clear</a>();
00366 }
00367 
00368 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00369"></a><a class="code" href="a00208.html#a11">00369</a> <span class="keywordtype">void</span> <a class="code" href="a00208.html">concurrent_queue&lt;T,A&gt;::clear</a>() {
00370     <span class="keywordflow">while</span>( !<a class="code" href="a00208.html#a7">empty</a>() ) {
00371         T value;
00372         <a class="code" href="a00209.html#b5">internal_pop_if_present</a>(&amp;value);
00373     }
00374 }
00375 
00376 } <span class="comment">// namespace tbb</span>
00377 
00378 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_queue_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
