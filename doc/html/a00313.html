<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_hash_map.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_hash_map.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_hash_map_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_hash_map_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00025 <span class="preprocessor">#include &lt;iterator&gt;</span>
00026 <span class="preprocessor">#include &lt;utility&gt;</span>      <span class="comment">// Need std::pair</span>
00027 <span class="preprocessor">#include &lt;cstring&gt;</span>      <span class="comment">// Need std::memset</span>
00028 <span class="preprocessor">#include &lt;string&gt;</span>
00029 <span class="preprocessor">#include "tbb_stddef.h"</span>
00030 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00031 <span class="preprocessor">#include "tbb_allocator.h"</span>
00032 <span class="preprocessor">#include "spin_rw_mutex.h"</span>
00033 <span class="preprocessor">#include "atomic.h"</span>
00034 <span class="preprocessor">#include "aligned_space.h"</span>
00035 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#include &lt;typeinfo&gt;</span>
00037 <span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="keyword">namespace </span>tbb {
00040 
00041 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>tbb_hash_compare;
00042 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare = tbb_hash_compare&lt;Key&gt;, <span class="keyword">typename</span> A = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt; &gt;
00043 <span class="keyword">class </span>concurrent_hash_map;
00044 
00046 <span class="keyword">namespace </span>internal {
<a name="l00048"></a><a class="code" href="a00303.html#a2">00048</a>     <span class="keyword">typedef</span> size_t hashcode_t;
<a name="l00050"></a><a class="code" href="a00213.html">00050</a>     <span class="keyword">class </span><a class="code" href="a00213.html">hash_map_base</a> {
00051     <span class="keyword">public</span>:
00052         <span class="comment">// Mutex types for each layer of the container</span>
00053         <span class="keyword">typedef</span> <a class="code" href="a00240.html">spin_rw_mutex</a> <a class="code" href="a00240.html">node_mutex_t</a>;
00054         <span class="keyword">typedef</span> <a class="code" href="a00240.html">spin_rw_mutex</a> <a class="code" href="a00240.html">chain_mutex_t</a>;
00055         <span class="keyword">typedef</span> <a class="code" href="a00240.html">spin_rw_mutex</a> <a class="code" href="a00240.html">segment_mutex_t</a>;
00056 
<a name="l00058"></a><a class="code" href="a00213.html#w3">00058</a>         <span class="keyword">typedef</span> <a class="code" href="a00303.html#a2">internal::hashcode_t</a> hashcode_t;
<a name="l00060"></a><a class="code" href="a00213.html#s0">00060</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment_bits = 6;
<a name="l00062"></a><a class="code" href="a00213.html#s1">00062</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment = size_t(1)&lt;&lt;n_segment_bits; 
<a name="l00064"></a><a class="code" href="a00213.html#s2">00064</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_physical_size = size_t(1)&lt;&lt;(8*<span class="keyword">sizeof</span>(hashcode_t)-n_segment_bits);
00065     };
00066 
00067     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00068     <span class="keyword">class </span><a class="code" href="a00214.html">hash_map_range</a>;
00069 
00070     <span class="keyword">struct </span>hash_map_segment_base {
00072         <a class="code" href="a00240.html">hash_map_base::segment_mutex_t</a> my_mutex;
00073 
00074         <span class="comment">// Number of nodes</span>
00075         <a class="code" href="a00182.html">atomic&lt;size_t&gt;</a> my_logical_size;
00076 
00077         <span class="comment">// Size of chains</span>
00079 <span class="comment"></span>        size_t my_physical_size;
00080 
00082 
00083         <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_grow_predicate() <span class="keyword">const</span>;
00084     };
00085 
00087 
00089     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00090     <span class="keyword">class </span>hash_map_iterator
<a name="l00091"></a><a class="code" href="a00303.html#a38">00091</a> #if <a class="code" href="a00303.html#a38">defined</a>(_WIN64) &amp;&amp; <a class="code" href="a00303.html#a38">defined</a>(_MSC_VER) 
00092         <span class="comment">// Ensure that Microsoft's internal template function _Val_type works correctly.</span>
00093         : public std::iterator&lt;std::forward_iterator_tag,Value&gt;
00094 #endif <span class="comment">/* defined(_WIN64) &amp;&amp; defined(_MSC_VER) */</span>
00095     {
00096         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::node node;
00097         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::chain chain;
00098         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::segment segment;
00099 
00101         Container* my_table;
00102 
00104         node* my_node;
00105 
00107         size_t my_array_index;
00108 
00110         size_t my_segment_index;
00111 
00112         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00113         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> hash_map_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;C,U&gt;&amp; j );
00114 
00115         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00116         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> hash_map_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;C,U&gt;&amp; j );
00117 
00118         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00119         <span class="keyword">friend</span> ptrdiff_t operator-( <span class="keyword">const</span> hash_map_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;C,U&gt;&amp; j );
00120     
00121         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U&gt;
00122         <span class="keyword">friend</span> <span class="keyword">class </span>internal::hash_map_iterator;
00123 
00124         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00125         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00214.html">internal::hash_map_range</a>;
00126 
00127         <span class="keywordtype">void</span> advance_to_next_node() {
00128             size_t i = my_array_index+1;
00129             <span class="keywordflow">do</span> {
00130                 segment &amp;s = my_table-&gt;my_segment[my_segment_index];
00131                 <span class="keywordflow">while</span>( i&lt;s.my_physical_size ) {
00132                     my_node = s.my_array[i].node_list;
00133                     <span class="keywordflow">if</span>( my_node ) <span class="keywordflow">goto</span> done;
00134                     ++i;
00135                 }
00136                 i = 0;
00137             } <span class="keywordflow">while</span>( ++my_segment_index&lt;my_table-&gt;n_segment );
00138         done:
00139             my_array_index = i;
00140         }
00141 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00142 <span class="preprocessor"></span>        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00143         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00192.html">tbb::concurrent_hash_map</a>;
00144 <span class="preprocessor">#else</span>
00145 <span class="preprocessor"></span>    <span class="keyword">public</span>: <span class="comment">// workaround</span>
00146 <span class="preprocessor">#endif</span>
00147 <span class="preprocessor"></span>        hash_map_iterator( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index=0, node* b=NULL );
00148     <span class="keyword">public</span>:
00150         hash_map_iterator() {}
00151         hash_map_iterator( <span class="keyword">const</span> hash_map_iterator&lt;Container,typename Container::value_type&gt;&amp; other ) :
00152             my_table(other.my_table),
00153             my_node(other.my_node),
00154             my_array_index(other.my_array_index),
00155             my_segment_index(other.my_segment_index)
00156         {}
00157         Value&amp; operator*()<span class="keyword"> const </span>{
00158             __TBB_ASSERT( my_node, <span class="stringliteral">"iterator uninitialized or at end of container?"</span> );
00159             <span class="keywordflow">return</span> my_node-&gt;item;
00160         }
00161         Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00162         hash_map_iterator&amp; operator++();
00163         
00165         Value* operator++(<span class="keywordtype">int</span>) {
00166             Value* result = &amp;operator*();
00167             operator++();
00168             <span class="keywordflow">return</span> result;
00169         }
00170 
00171         <span class="comment">// STL support</span>
00172 
00173         <span class="keyword">typedef</span> ptrdiff_t difference_type;
00174         <span class="keyword">typedef</span> Value value_type;
00175         <span class="keyword">typedef</span> Value* pointer;
00176         <span class="keyword">typedef</span> Value&amp; reference;
00177         <span class="keyword">typedef</span> <span class="keyword">const</span> Value&amp; const_reference;
00178         <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;
00179     };
00180 
00181     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00182     hash_map_iterator&lt;Container,Value&gt;::hash_map_iterator( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index, node* b ) : 
00183         my_table(const_cast&lt;Container*&gt;(&amp;table)),
00184         my_node(b),
00185         my_array_index(array_index),
00186         my_segment_index(segment_index)
00187     {
00188         <span class="keywordflow">if</span>( segment_index&lt;my_table-&gt;n_segment ) {
00189             <span class="keywordflow">if</span>( !my_node ) {
00190                 segment &amp;s = my_table-&gt;my_segment[segment_index];
00191                 chain* first_chain = s.my_array;
00192                 <span class="keywordflow">if</span>( first_chain &amp;&amp; my_array_index &lt; s.my_physical_size)
00193                     my_node = first_chain[my_array_index].node_list;
00194             }
00195             <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00196         }
00197     }
00198 
00199     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00200     hash_map_iterator&lt;Container,Value&gt;&amp; hash_map_iterator&lt;Container,Value&gt;::operator++() {
00201         my_node=my_node-&gt;next;
00202         <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00203         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00204     }
00205 
00206     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00207     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00208         <span class="keywordflow">return</span> i.my_node==j.my_node;
00209     }
00210 
00211     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00212     <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00213         <span class="keywordflow">return</span> i.my_node!=j.my_node;
00214     }
00215 
00217 
00218     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00219"></a><a class="code" href="a00214.html">00219</a>     <span class="keyword">class </span><a class="code" href="a00214.html">hash_map_range</a> {
00220     <span class="keyword">private</span>:
00221         Iterator my_begin;
00222         Iterator my_end;
00223         <span class="keyword">mutable</span> Iterator my_midpoint;
00224         size_t my_grainsize;
00226         <span class="keywordtype">void</span> set_midpoint() <span class="keyword">const</span>;
00227         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00214.html">hash_map_range</a>;
00228     <span class="keyword">public</span>:
<a name="l00230"></a><a class="code" href="a00214.html#w0">00230</a>         <span class="keyword">typedef</span> std::size_t size_type;
00231         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;
00232         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference;
00233         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::const_reference const_reference;
00234         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type;
00235         <span class="keyword">typedef</span> Iterator iterator;
00236 
<a name="l00238"></a><a class="code" href="a00214.html#a0">00238</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin==my_end;}
00239 
<a name="l00241"></a><a class="code" href="a00214.html#a1">00241</a>         <span class="keywordtype">bool</span> is_divisible()<span class="keyword"> const </span>{
00242             <span class="keywordflow">return</span> my_midpoint!=my_end;
00243         }
<a name="l00245"></a><a class="code" href="a00214.html#a2">00245</a>         <a class="code" href="a00214.html">hash_map_range</a>( <a class="code" href="a00214.html">hash_map_range</a>&amp; r, <a class="code" href="a00242.html">split</a> ) : 
00246             my_end(r.my_end),
00247             my_grainsize(r.my_grainsize)
00248         {
00249             r.<a class="code" href="a00214.html#r1">my_end</a> = my_begin = r.<a class="code" href="a00214.html#r2">my_midpoint</a>;
00250             __TBB_ASSERT( my_begin!=my_end, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00251             __TBB_ASSERT( r.<a class="code" href="a00214.html#r0">my_begin</a>!=r.<a class="code" href="a00214.html#r1">my_end</a>, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00252             set_midpoint();
00253             r.<a class="code" href="a00214.html#d0">set_midpoint</a>();
00254         }
00256         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
<a name="l00257"></a><a class="code" href="a00214.html#a3">00257</a>         <a class="code" href="a00214.html">hash_map_range</a>( <a class="code" href="a00214.html">hash_map_range&lt;U&gt;</a>&amp; r) : 
00258             my_begin(r.my_begin),
00259             my_end(r.my_end),
00260             my_midpoint(r.my_midpoint),
00261             my_grainsize(r.my_grainsize)
00262         {}
<a name="l00264"></a><a class="code" href="a00214.html#a4">00264</a>         <a class="code" href="a00214.html">hash_map_range</a>( <span class="keyword">const</span> Iterator&amp; begin_, <span class="keyword">const</span> Iterator&amp; end_, size_type grainsize = 1 ) : 
00265             my_begin(begin_), 
00266             my_end(end_), 
00267             my_grainsize(grainsize) 
00268         {
00269             set_midpoint();
00270             __TBB_ASSERT( grainsize&gt;0, <span class="stringliteral">"grainsize must be positive"</span> );
00271         }
00272         <span class="keyword">const</span> Iterator&amp; begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin;}
00273         <span class="keyword">const</span> Iterator&amp; end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_end;}
<a name="l00275"></a><a class="code" href="a00214.html#a7">00275</a>         size_type grainsize()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_grainsize;}
00276     };
00277 
00278     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00279     <span class="keywordtype">void</span> hash_map_range&lt;Iterator&gt;::set_midpoint()<span class="keyword"> const </span>{
00280         size_t n = my_end.my_segment_index - my_begin.my_segment_index;
00281         <span class="keywordflow">if</span>( n &gt; 1 || (n == 1 &amp;&amp; my_end.my_array_index &gt; my_grainsize/2) ) {
00282             <span class="comment">// Split by groups of segments</span>
00283             my_midpoint = Iterator(*my_begin.my_table,(my_end.my_segment_index+my_begin.my_segment_index+1)/2u);
00284         } <span class="keywordflow">else</span> {
00285             <span class="comment">// Split by groups of nodes</span>
00286             size_t m = my_end.my_array_index-my_begin.my_array_index;
00287             <span class="keywordflow">if</span>( n ) m += my_begin.my_table-&gt;my_segment[my_begin.my_segment_index].my_physical_size;
00288             <span class="keywordflow">if</span>( m &gt; my_grainsize ) {
00289                 my_midpoint = Iterator(*my_begin.my_table,my_begin.my_segment_index,my_begin.my_array_index + m/2u);
00290             } <span class="keywordflow">else</span> {
00291                 my_midpoint = my_end;
00292             }
00293         }
00294         __TBB_ASSERT( my_begin.my_segment_index &lt; my_midpoint.my_segment_index
00295             || (my_begin.my_segment_index == my_midpoint.my_segment_index
00296             &amp;&amp; my_begin.my_array_index &lt;= my_midpoint.my_array_index),
00297             <span class="stringliteral">"my_begin is after my_midpoint"</span> );
00298         __TBB_ASSERT( my_midpoint.my_segment_index &lt; my_end.my_segment_index
00299             || (my_midpoint.my_segment_index == my_end.my_segment_index
00300             &amp;&amp; my_midpoint.my_array_index &lt;= my_end.my_array_index),
00301             <span class="stringliteral">"my_midpoint is after my_end"</span> );
00302         __TBB_ASSERT( my_begin != my_midpoint || my_begin == my_end,
00303             <span class="stringliteral">"[my_begin, my_midpoint) range should not be empty"</span> );
00304     }
<a name="l00306"></a><a class="code" href="a00303.html#a3">00306</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="a00303.html#a2">hashcode_t</a> <a class="code" href="a00303.html#a3">hash_multiplier</a> = <span class="keyword">sizeof</span>(hashcode_t)==4? 2654435769U : 11400714819323198485ULL;
00308     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00309"></a><a class="code" href="a00303.html#a41">00309</a>     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="a00303.html#a2">hashcode_t</a> <a class="code" href="a00303.html#a41">hasher</a>( <span class="keyword">const</span> T&amp; t ) {
00310         <span class="keywordflow">return</span> static_cast&lt;hashcode_t&gt;( t ) * hash_multiplier;
00311     }
00312     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;
00313     <span class="keyword">inline</span> <span class="keyword">static</span> hashcode_t <a class="code" href="a00303.html#a41">hasher</a>( P* ptr ) {
00314         hashcode_t <span class="keyword">const</span> h = reinterpret_cast&lt;hashcode_t&gt;( ptr );
00315         <span class="keywordflow">return</span> (h &gt;&gt; 3) ^ h;
00316     }
00317     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> S, <span class="keyword">typename</span> A&gt;
00318     <span class="keyword">inline</span> <span class="keyword">static</span> hashcode_t <a class="code" href="a00303.html#a41">hasher</a>( <span class="keyword">const</span> std::basic_string&lt;E,S,A&gt;&amp; s ) {
00319         hashcode_t h = 0;
00320         <span class="keywordflow">for</span>( <span class="keyword">const</span> E* c = s.c_str(); *c; c++ )
00321             h = static_cast&lt;hashcode_t&gt;(*c) ^ (h * hash_multiplier);
00322         <span class="keywordflow">return</span> h;
00323     }
00324     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> S&gt;
00325     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="a00303.html#a2">hashcode_t</a> <a class="code" href="a00303.html#a41">hasher</a>( <span class="keyword">const</span> std::pair&lt;F,S&gt;&amp; p ) {
00326         <span class="keywordflow">return</span> <a class="code" href="a00303.html#a41">hasher</a>(p.first) ^ <a class="code" href="a00303.html#a41">hasher</a>(p.second);
00327     }
00328 } <span class="comment">// namespace internal</span>
00330 <span class="comment"></span>
00332 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00333"></a><a class="code" href="a00257.html">00333</a> <span class="keyword">struct </span><a class="code" href="a00257.html">tbb_hash_compare</a> {
00334     <span class="keyword">static</span> <a class="code" href="a00303.html#a2">internal::hashcode_t</a> hash( <span class="keyword">const</span> T&amp; t ) { <span class="keywordflow">return</span> internal::hasher(t); }
00335     <span class="keyword">static</span> <span class="keywordtype">bool</span> equal( <span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b ) { <span class="keywordflow">return</span> a == b; }
00336 };
00337 
00339 
00364 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00365"></a><a class="code" href="a00192.html">00365</a> <span class="keyword">class </span><a class="code" href="a00192.html">concurrent_hash_map</a> : <span class="keyword">protected</span> internal::hash_map_base {
00366     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00367     <span class="keyword">friend</span> <span class="keyword">class </span>internal::hash_map_iterator;
00368 
00369     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00370     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00214.html">internal::hash_map_range</a>;
00371 
00372     <span class="keyword">struct </span>node;
00373     <span class="keyword">friend</span> <span class="keyword">struct </span>node;
00374     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;node&gt;::other node_allocator_type;
00375 
00376 <span class="keyword">public</span>:
00377     <span class="keyword">class </span><a class="code" href="a00194.html">const_accessor</a>;
00378     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00194.html">const_accessor</a>;
00379     <span class="keyword">class </span><a class="code" href="a00193.html">accessor</a>;
00380 
00381     <span class="keyword">typedef</span> Key key_type;
00382     <span class="keyword">typedef</span> T mapped_type;
00383     <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00384     <span class="keyword">typedef</span> size_t size_type;
00385     <span class="keyword">typedef</span> ptrdiff_t difference_type;
00386     <span class="keyword">typedef</span> value_type *pointer;
00387     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;
00388     <span class="keyword">typedef</span> value_type &amp;reference;
00389     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type &amp;const_reference;
00390     <span class="keyword">typedef</span> internal::hash_map_iterator&lt;concurrent_hash_map,value_type&gt; iterator;
00391     <span class="keyword">typedef</span> internal::hash_map_iterator&lt;concurrent_hash_map,const value_type&gt; const_iterator;
00392     <span class="keyword">typedef</span> <a class="code" href="a00214.html">internal::hash_map_range&lt;iterator&gt;</a> <a class="code" href="a00214.html">range_type</a>;
00393     <span class="keyword">typedef</span> <a class="code" href="a00214.html">internal::hash_map_range&lt;const_iterator&gt;</a> <a class="code" href="a00214.html">const_range_type</a>;
00394     <span class="keyword">typedef</span> A allocator_type;
00395 
<a name="l00397"></a><a class="code" href="a00194.html">00397</a>     <span class="keyword">class </span><a class="code" href="a00194.html">const_accessor</a> {
00398         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00192.html">concurrent_hash_map</a>;
00399         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00193.html">accessor</a>;
00400         <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="a00193.html">accessor</a>&amp; ) <span class="keyword">const</span>; <span class="comment">// Deny access</span>
00401         <a class="code" href="a00194.html">const_accessor</a>( <span class="keyword">const</span> <a class="code" href="a00193.html">accessor</a>&amp; );       <span class="comment">// Deny access</span>
00402     <span class="keyword">public</span>:
<a name="l00404"></a><a class="code" href="a00194.html#w0">00404</a>         <span class="keyword">typedef</span> <span class="keyword">const</span> std::pair&lt;const Key,T&gt; value_type;
00405 
<a name="l00407"></a><a class="code" href="a00194.html#a0">00407</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> !my_node;}
00408 
<a name="l00410"></a><a class="code" href="a00194.html#a1">00410</a>         <span class="keywordtype">void</span> <a class="code" href="a00302.html#a55a2">release</a>() {
00411             <span class="keywordflow">if</span>( my_node ) {
00412                 my_lock.release();
00413                 my_node = NULL;
00414             }
00415         }
00416 
<a name="l00418"></a><a class="code" href="a00194.html#a2">00418</a>         const_reference operator*()<span class="keyword"> const </span>{
00419             __TBB_ASSERT( my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00420             <span class="keywordflow">return</span> my_node-&gt;item;
00421         }
00422 
<a name="l00424"></a><a class="code" href="a00194.html#a3">00424</a>         const_pointer operator-&gt;()<span class="keyword"> const </span>{
00425             <span class="keywordflow">return</span> &amp;operator*();
00426         }
00427 
<a name="l00429"></a><a class="code" href="a00194.html#a4">00429</a>         <a class="code" href="a00194.html">const_accessor</a>() : my_node(NULL) {}
00430 
<a name="l00432"></a><a class="code" href="a00194.html#a5">00432</a>         ~<a class="code" href="a00194.html">const_accessor</a>() {
00433             my_node = NULL; <span class="comment">// my_lock.release() is called in scoped_lock destructor</span>
00434         }
00435     <span class="keyword">private</span>:
00436         node* my_node;
00437         node_mutex_t::scoped_lock my_lock;
00438         hashcode_t my_hash;
00439     };
00440 
<a name="l00442"></a><a class="code" href="a00193.html">00442</a>     <span class="keyword">class </span><a class="code" href="a00193.html">accessor</a>: <span class="keyword">public</span> <a class="code" href="a00194.html">const_accessor</a> {
00443     <span class="keyword">public</span>:
<a name="l00445"></a><a class="code" href="a00193.html#w0">00445</a>         <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00446 
<a name="l00448"></a><a class="code" href="a00193.html#a0">00448</a>         reference operator*()<span class="keyword"> const </span>{
00449             __TBB_ASSERT( this-&gt;my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00450             <span class="keywordflow">return</span> this-&gt;my_node-&gt;item;
00451         }
00452 
<a name="l00454"></a><a class="code" href="a00193.html#a1">00454</a>         pointer operator-&gt;()<span class="keyword"> const </span>{
00455             <span class="keywordflow">return</span> &amp;operator*();
00456         }       
00457     };
00458 
<a name="l00460"></a><a class="code" href="a00192.html#a0">00460</a>     <a class="code" href="a00192.html">concurrent_hash_map</a>(<span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00461         : my_allocator(a)
00462 
00463     {
00464         initialize();
00465     }
00466 
<a name="l00468"></a><a class="code" href="a00192.html#a1">00468</a>     <a class="code" href="a00192.html">concurrent_hash_map</a>( <span class="keyword">const</span> <a class="code" href="a00192.html">concurrent_hash_map</a>&amp; table, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00469         : my_allocator(a)
00470     {
00471         initialize();
00472         internal_copy(table);
00473     }
00474 
00476     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00477"></a><a class="code" href="a00192.html#a2">00477</a>     <a class="code" href="a00192.html">concurrent_hash_map</a>(I first, I last, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00478         : my_allocator(a)
00479     {
00480         initialize();
00481         internal_copy(first, last);
00482     }
00483 
<a name="l00485"></a><a class="code" href="a00192.html#a3">00485</a>     <a class="code" href="a00192.html">concurrent_hash_map</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00192.html">concurrent_hash_map</a>&amp; table ) {
00486         <span class="keywordflow">if</span>( <span class="keyword">this</span>!=&amp;table ) {
00487             clear();
00488             internal_copy(table);
00489         } 
00490         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00491     }
00492 
00493 
00495     <span class="keywordtype">void</span> clear();
00496 
00498     ~<a class="code" href="a00192.html">concurrent_hash_map</a>();
00499 
00500     <span class="comment">//------------------------------------------------------------------------</span>
00501     <span class="comment">// Parallel algorithm support</span>
00502     <span class="comment">//------------------------------------------------------------------------</span>
00503     range_type range( size_type grainsize=1 ) {
00504         <span class="keywordflow">return</span> range_type( begin(), end(), grainsize );
00505     }
00506     const_range_type range( size_type grainsize=1 )<span class="keyword"> const </span>{
00507         <span class="keywordflow">return</span> const_range_type( begin(), end(), grainsize );
00508     }
00509 
00510     <span class="comment">//------------------------------------------------------------------------</span>
00511     <span class="comment">// STL support - not thread-safe methods</span>
00512     <span class="comment">//------------------------------------------------------------------------</span>
00513     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,0);}
00514     iterator end() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,n_segment);}
00515     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,0);}
00516     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,n_segment);}
00517     std::pair&lt;iterator, iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key ) { <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00518     std::pair&lt;const_iterator, const_iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00519     
00521 
00523     size_type size() <span class="keyword">const</span>;
00524 
00526     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
00527 
<a name="l00529"></a><a class="code" href="a00192.html#a16">00529</a>     size_type max_size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> (~size_type(0))/<span class="keyword">sizeof</span>(node);}
00530 
<a name="l00532"></a><a class="code" href="a00192.html#a17">00532</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00533 
00535     <span class="keywordtype">void</span> swap(<a class="code" href="a00192.html">concurrent_hash_map</a> &amp;table);
00536 
00537     <span class="comment">//------------------------------------------------------------------------</span>
00538     <span class="comment">// concurrent map operations</span>
00539     <span class="comment">//------------------------------------------------------------------------</span>
00540 
<a name="l00542"></a><a class="code" href="a00192.html#a19">00542</a>     size_type count( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00543         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(NULL, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00544     }
00545 
00547 
<a name="l00548"></a><a class="code" href="a00192.html#a20">00548</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00194.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00549         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00550     }
00551 
00553 
<a name="l00554"></a><a class="code" href="a00192.html#a21">00554</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00193.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00555         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00556     }
00557         
00559 
<a name="l00560"></a><a class="code" href="a00192.html#a22">00560</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00194.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00561         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00562     }
00563 
00565 
<a name="l00566"></a><a class="code" href="a00192.html#a23">00566</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00193.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00567         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00568     }
00569 
00571 
<a name="l00572"></a><a class="code" href="a00192.html#a24">00572</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00194.html">const_accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00573         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00574     }
00575 
00577 
<a name="l00578"></a><a class="code" href="a00192.html#a25">00578</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00193.html">accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00579         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">true</span>, &amp;value.second );
00580     }
00581 
00583 
<a name="l00584"></a><a class="code" href="a00192.html#a26">00584</a>     <span class="keywordtype">bool</span> insert( <span class="keyword">const</span> value_type&amp; value ) {
00585         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(NULL, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00586     }
00587 
00589     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00590"></a><a class="code" href="a00192.html#a27">00590</a>     <span class="keywordtype">void</span> insert(I first, I last) {
00591         <span class="keywordflow">for</span>(; first != last; ++first)
00592             insert( *first );
00593     }
00594 
00596 
00597     <span class="keywordtype">bool</span> erase( <span class="keyword">const</span> Key&amp; key );
00598 
00600 
<a name="l00601"></a><a class="code" href="a00192.html#a29">00601</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00194.html">const_accessor</a>&amp; item_accessor ) {
00602         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">true</span> );
00603     }
00604 
00606 
<a name="l00607"></a><a class="code" href="a00192.html#a30">00607</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00193.html">accessor</a>&amp; item_accessor ) {
00608         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">false</span> );
00609     }
00610 
00611 <span class="keyword">private</span>:
00613     <span class="keyword">struct </span>node {
00615         node* next;
00616         node_mutex_t <a class="code" href="a00217.html">mutex</a>;
00617         value_type item;
00618         node( <span class="keyword">const</span> Key&amp; key ) : item(key, T()) {}
00619         node( <span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T&amp; t ) : item(key, t) {}
00620         <span class="comment">// exception-safe allocation, see C++ Standard 2003, clause 5.3.4p17</span>
00621         <span class="keywordtype">void</span>* operator new( size_t size, node_allocator_type&amp; a ) {
00622             <span class="keywordtype">void</span> *ptr = a.allocate(1);
00623             <span class="keywordflow">if</span>(!ptr) <span class="keywordflow">throw</span> std::bad_alloc();
00624             <span class="keywordflow">return</span> ptr;
00625         }
00626         <span class="comment">// match placement-new form above to be called if exception thrown in constructor</span>
00627         <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* ptr, node_allocator_type&amp; a ) {<span class="keywordflow">return</span> a.deallocate(static_cast&lt;node*&gt;(ptr),1); }
00628     };
00629 
00630     <span class="keyword">struct </span>chain;
00631     <span class="keyword">friend</span> <span class="keyword">struct </span>chain;
00632 
00634 
00635     <span class="keyword">struct </span>chain {
00636         <span class="keywordtype">void</span> push_front( node&amp; b ) {
00637             b.next = node_list;
00638             node_list = &amp;b;
00639         }
00640         chain_mutex_t mutex;
00641         node* node_list;
00642     };
00643 
00644     <span class="keyword">struct </span>segment;
00645     <span class="keyword">friend</span> <span class="keyword">struct </span>segment;
00646 
00648 
00650     <span class="keyword">struct </span>segment: internal::hash_map_segment_base {
00651 <span class="preprocessor">#if TBB_DO_ASSERT</span>
00652 <span class="preprocessor"></span>        ~segment() {
00653             __TBB_ASSERT( !my_array, <span class="stringliteral">"should have been cleared earlier"</span> );
00654         }
00655 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_ASSERT */</span>
00656 
00657         <span class="comment">// Pointer to array of chains</span>
00658         chain* my_array;
00659 
00660         <span class="comment">// Get chain in this segment that corresponds to given hash code.</span>
00661         chain&amp; get_chain( hashcode_t hashcode, size_t n_segment_bits ) {
00662             <span class="keywordflow">return</span> my_array[(hashcode&gt;&gt;n_segment_bits)&amp;(my_physical_size-1)];
00663         }
00664      
00666 
00668         <span class="keywordtype">void</span> allocate_array( size_t new_size ) {
00669             size_t n=(internal::NFS_GetLineSize()+<span class="keyword">sizeof</span>(chain)-1)/<span class="keyword">sizeof</span>(chain);
00670             __TBB_ASSERT((n&amp;(n-1))==0, NULL);
00671             <span class="keywordflow">while</span>( n&lt;new_size ) n&lt;&lt;=1;
00672             chain* array = cache_aligned_allocator&lt;chain&gt;().allocate( n );
00673             <span class="comment">// storing earlier might help overcome false positives of in deducing "bool grow" in concurrent threads</span>
00674             __TBB_store_with_release(my_physical_size, n);
00675             std::memset( array, 0, n*<span class="keyword">sizeof</span>(chain) );
00676             my_array = array;
00677         }
00678     };
00679 
00680     segment&amp; get_segment( hashcode_t hashcode ) {
00681         <span class="keywordflow">return</span> my_segment[hashcode&amp;(n_segment-1)];
00682     }
00683 
00684     node_allocator_type my_allocator;
00685 
00686     HashCompare my_hash_compare;
00687 
00688     segment* my_segment;
00689 
00690     node* create_node(<span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T* t) {
00691         <span class="comment">// exception-safe allocation and construction</span>
00692         <span class="keywordflow">if</span>(t) <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key, *t);
00693         <span class="keywordflow">else</span>  <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key);
00694     }
00695 
00696     <span class="keywordtype">void</span> delete_node(node* b) {
00697         my_allocator.destroy(b);
00698         my_allocator.deallocate(b, 1);
00699     }
00700 
00701     node* search_list( <span class="keyword">const</span> Key&amp; key, chain&amp; c )<span class="keyword"> const </span>{
00702         node* b = c.node_list;
00703         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first) )
00704             b = b-&gt;next;
00705         <span class="keywordflow">return</span> b;
00706     }
00708     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00709     std::pair&lt;I, I&gt; internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end ) <span class="keyword">const</span>;
00710 
00712     <span class="keywordtype">bool</span> exclude( const_accessor&amp; item_accessor, <span class="keywordtype">bool</span> readonly );
00713 
00715     <span class="keywordtype">void</span> grow_segment( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s );
00716 
00718     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00719     <span class="keywordtype">bool</span> lookup( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t );
00720 
00722     <span class="keywordtype">void</span> initialize() {
00723         my_segment = cache_aligned_allocator&lt;segment&gt;().allocate(n_segment);
00724         std::memset( my_segment, 0, <span class="keyword">sizeof</span>(segment)*n_segment );
00725      }
00726 
00728     <span class="keywordtype">void</span> internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source );
00729 
00730     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00731     <span class="keywordtype">void</span> internal_copy(I first, I last);
00732 };
00733 
00734 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00735"></a><a class="code" href="a00192.html#a5">00735</a> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::~concurrent_hash_map</a>() {
00736     <a class="code" href="a00192.html#a4">clear</a>();
00737     <a class="code" href="a00189.html">cache_aligned_allocator&lt;segment&gt;</a>().deallocate( my_segment, n_segment );
00738 }
00739 
00740 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00741"></a><a class="code" href="a00192.html#a14">00741</a> <span class="keyword">typename</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a>::size_type <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::size</a>()<span class="keyword"> const </span>{
00742     size_type result = 0;
00743     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00744         result += my_segment[k].my_logical_size;
00745     <span class="keywordflow">return</span> result;
00746 }
00747 
00748 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00749"></a><a class="code" href="a00192.html#a15">00749</a> <span class="keywordtype">bool</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::empty</a>()<span class="keyword"> const </span>{
00750     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00751         <span class="keywordflow">if</span>( my_segment[k].my_logical_size )
00752             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00753     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00754 }
00755 
00756 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00757 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00758 <span class="keywordtype">bool</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::lookup</a>( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t ) {
00759     <span class="keywordflow">if</span>( result <span class="comment">/*&amp;&amp; result-&gt;my_node -- checked in release() */</span> )
00760         result-&gt;release();
00761     <span class="keyword">const</span> hashcode_t h = my_hash_compare.hash( key );
00762     segment&amp; s = get_segment(h);
00763 restart:
00764     <span class="keywordtype">bool</span> return_value = <span class="keyword">false</span>;
00765     <span class="comment">// first check in double-check sequence</span>
00766 <span class="preprocessor">#if TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT</span>
00767 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.internal_grow_predicate();
00768 <span class="preprocessor">#else</span>
00769 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.my_logical_size &gt;= s.my_physical_size
00770         &amp;&amp; s.my_physical_size &lt; max_physical_size; <span class="comment">// check whether there are free bits</span>
00771 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT */</span>
00772     segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span>grow );
00773     <span class="keywordflow">if</span>( grow ) { <span class="comment">// Load factor is too high  </span>
00774         grow_segment( segment_lock, s );
00775     }
00776     <span class="keywordflow">if</span>( !s.my_array ) {
00777         __TBB_ASSERT( !op_insert, NULL );
00778         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00779     }
00780     __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00781     chain&amp; c = s.get_chain( h, n_segment_bits );
00782     chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00783 
00784     node* b = search_list( key, c );
00785     <span class="keywordflow">if</span>( op_insert ) {
00786         <span class="keywordflow">if</span>( !b ) {
00787             b = create_node(key, t);
00788             <span class="comment">// Search failed</span>
00789             <span class="keywordflow">if</span>( !chain_lock.upgrade_to_writer() ) {
00790                 <span class="comment">// Rerun search_list, in case another thread inserted the item during the upgrade.</span>
00791                 node* b_temp = search_list( key, c );
00792                 <span class="keywordflow">if</span>( b_temp ) { <span class="comment">// unfortunately, it did</span>
00793                     chain_lock.downgrade_to_reader();
00794                     delete_node( b );
00795                     b = b_temp;
00796                     <span class="keywordflow">goto</span> done;
00797                 }
00798             }
00799             ++s.my_logical_size; <span class="comment">// we can't change it earlier due to correctness of size() and exception safety of equal()</span>
00800             return_value = <span class="keyword">true</span>;
00801             c.push_front( *b );
00802         }
00803     } <span class="keywordflow">else</span> { <span class="comment">// find or count</span>
00804         <span class="keywordflow">if</span>( !b )      <span class="keywordflow">return</span> <span class="keyword">false</span>;
00805         return_value = <span class="keyword">true</span>;
00806     }
00807 done:
00808     <span class="keywordflow">if</span>( !result ) <span class="keywordflow">return</span> return_value;
00809     <span class="keywordflow">if</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) ) {
00810         <span class="comment">// we are unlucky, prepare for longer wait</span>
00811         internal::AtomicBackoff trials;
00812         <span class="keywordflow">do</span> {
00813             <span class="keywordflow">if</span>( !trials.bounded_pause() ) {
00814                 <span class="comment">// the wait takes really long, restart the operation</span>
00815                 chain_lock.release(); segment_lock.release();
00816                 __TBB_Yield();
00817                 <span class="keywordflow">goto</span> restart;
00818             }
00819         } <span class="keywordflow">while</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) );
00820     }
00821     result-&gt;my_node = b;
00822     result-&gt;my_hash = h;
00823     <span class="keywordflow">return</span> return_value;
00824 }
00825 
00826 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00827 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00828 std::pair&lt;I, I&gt; concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end )<span class="keyword"> const </span>{
00829     <a class="code" href="a00213.html#w3">hashcode_t</a> h = my_hash_compare.hash( key );
00830     size_t segment_index = h&amp;(<a class="code" href="a00213.html#s1">n_segment</a>-1);
00831     segment&amp; s = my_segment[segment_index ];
00832     size_t chain_index = (h&gt;&gt;n_segment_bits)&amp;(s.my_physical_size-1);
00833     <span class="keywordflow">if</span>( !s.my_array )
00834         <span class="keywordflow">return</span> std::make_pair(end, end);
00835     chain&amp; c = s.my_array[chain_index];
00836     node* b = search_list( key, c );
00837     <span class="keywordflow">if</span>( !b )
00838         <span class="keywordflow">return</span> std::make_pair(end, end);
00839     iterator lower(*<span class="keyword">this</span>, segment_index, chain_index, b), upper(lower);
00840     <span class="keywordflow">return</span> std::make_pair(lower, ++upper);
00841 }
00842 
00843 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00844"></a><a class="code" href="a00192.html#a28">00844</a> <span class="keywordtype">bool</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::erase</a>( <span class="keyword">const</span> Key &amp;key ) {
00845     hashcode_t h = my_hash_compare.hash( key );
00846     segment&amp; s = get_segment( h );
00847     node* b=NULL; <span class="comment">// explicitly initialized to prevent compiler warnings</span>
00848     {
00849         <span class="keywordtype">bool</span> chain_locked_for_write = <span class="keyword">false</span>;
00850         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00851         <span class="keywordflow">if</span>( !s.my_array ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00852         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00853         chain&amp; c = s.get_chain( h, n_segment_bits );
00854         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00855     search:
00856         node** p = &amp;c.node_list;
00857         b = *p;
00858         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first ) ) {
00859             p = &amp;b-&gt;next;
00860             b = *p;
00861         }
00862         <span class="keywordflow">if</span>( !b ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00863         <span class="keywordflow">if</span>( !chain_locked_for_write &amp;&amp; !chain_lock.upgrade_to_writer() ) {
00864             chain_locked_for_write = <span class="keyword">true</span>;
00865             <span class="keywordflow">goto</span> search;
00866         }
00867         *p = b-&gt;next;
00868         --s.my_logical_size;
00869     }
00870     {
00871         node_mutex_t::scoped_lock item_locker( b-&gt;mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00872     }
00873     <span class="comment">// note: there should be no threads pretending to acquire this mutex again, do not try to upgrade const_accessor!</span>
00874     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00875     <span class="keywordflow">return</span> <span class="keyword">true</span>;        
00876 }
00877 
00878 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00879 <span class="keywordtype">bool</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::exclude</a>( const_accessor &amp;item_accessor, <span class="keywordtype">bool</span> readonly ) {
00880     __TBB_ASSERT( item_accessor.my_node, NULL );
00881     <span class="keyword">const</span> hashcode_t h = item_accessor.my_hash;
00882     node *<span class="keyword">const</span> b = item_accessor.my_node;
00883     item_accessor.my_node = NULL; <span class="comment">// we ought release accessor anyway</span>
00884     segment&amp; s = get_segment( h );
00885     {
00886         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00887         __TBB_ASSERT( s.my_array, NULL );
00888         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00889         chain&amp; c = s.get_chain( h, n_segment_bits );
00890         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00891         node** p = &amp;c.node_list;
00892         <span class="keywordflow">while</span>( *p &amp;&amp; *p != b )
00893             p = &amp;(*p)-&gt;next;
00894         <span class="keywordflow">if</span>( !*p ) { <span class="comment">// someone else was the first</span>
00895             item_accessor.my_lock.release();
00896             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00897         }
00898         __TBB_ASSERT( *p == b, NULL );
00899         *p = b-&gt;next;
00900         --s.my_logical_size;
00901     }
00902     <span class="keywordflow">if</span>( readonly ) <span class="comment">// need to get exclusive lock</span>
00903         item_accessor.my_lock.upgrade_to_writer(); <span class="comment">// return value means nothing here</span>
00904     item_accessor.my_lock.release();
00905     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00906     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00907 }
00908 
00909 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00910"></a><a class="code" href="a00192.html#a18">00910</a> <span class="keywordtype">void</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::swap</a>(<a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a> &amp;table) {
00911     std::swap(this-&gt;my_allocator, table.<a class="code" href="a00192.html#r0">my_allocator</a>);
00912     std::swap(this-&gt;my_hash_compare, table.<a class="code" href="a00192.html#r1">my_hash_compare</a>);
00913     std::swap(this-&gt;my_segment, table.<a class="code" href="a00192.html#r2">my_segment</a>);
00914 }
00915 
00916 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00917"></a><a class="code" href="a00192.html#a4">00917</a> <span class="keywordtype">void</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::clear</a>() {
00918 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00919 <span class="preprocessor"></span>    size_t total_physical_size = 0, min_physical_size = size_t(-1L), max_physical_size = 0; <span class="comment">//&lt; usage statistics</span>
00920     <span class="keyword">static</span> <span class="keywordtype">bool</span> reported = <span class="keyword">false</span>;
00921 <span class="preprocessor">#endif</span>
00922 <span class="preprocessor"></span>    <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00923         segment&amp; s = my_segment[i];
00924         size_t n = s.my_physical_size;
00925         <span class="keywordflow">if</span>( chain* array = s.my_array ) {
00926             s.my_array = NULL;
00927             s.my_physical_size = 0;
00928             s.my_logical_size = 0;
00929             <span class="keywordflow">for</span>( size_t j=0; j&lt;n; ++j ) {
00930                 <span class="keywordflow">while</span>( node* b = array[j].node_list ) {
00931                     array[j].node_list = b-&gt;next;
00932                     delete_node(b);
00933                 }
00934             }
00935             <a class="code" href="a00189.html">cache_aligned_allocator&lt;chain&gt;</a>().deallocate( array, n );
00936         }
00937 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00938 <span class="preprocessor"></span>        total_physical_size += n;
00939         <span class="keywordflow">if</span>(min_physical_size &gt; n) min_physical_size = n;
00940         <span class="keywordflow">if</span>(max_physical_size &lt; n) max_physical_size = n;
00941     }
00942     <span class="keywordflow">if</span>( !reported
00943         &amp;&amp; ( (total_physical_size &gt;= n_segment*48 &amp;&amp; min_physical_size &lt; total_physical_size/n_segment/2)
00944          || (total_physical_size &gt;= n_segment*128 &amp;&amp; max_physical_size &gt; total_physical_size/n_segment*2) ) )
00945     {
00946         reported = <span class="keyword">true</span>;
00947         internal::runtime_warning(
00948             <span class="stringliteral">"Performance is not optimal because the hash function produces bad randomness in lower bits in %s"</span>,
00949             <span class="keyword">typeid</span>(*this).name() );
00950 <span class="preprocessor">#endif</span>
00951 <span class="preprocessor"></span>    }
00952 }
00953 
00954 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00955 <span class="keywordtype">void</span> <a class="code" href="a00192.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::grow_segment</a>( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s ) {
00956     <span class="comment">// Following is second check in a double-check.</span>
00957     <span class="keywordflow">if</span>( s.my_logical_size &gt;= s.my_physical_size ) {
00958         chain* old_array = s.my_array;
00959         size_t old_size = s.my_physical_size;
00960         s.allocate_array( s.my_logical_size+1 );
00961         <span class="keywordflow">for</span>( size_t k=0; k&lt;old_size; ++k )
00962             <span class="keywordflow">while</span>( node* b = old_array[k].node_list ) {
00963                 old_array[k].node_list = b-&gt;next;
00964                 hashcode_t h = my_hash_compare.hash( b-&gt;item.first );
00965                 __TBB_ASSERT( &amp;get_segment(h)==&amp;s, <span class="stringliteral">"hash function changed?"</span> );
00966                 s.get_chain(h,n_segment_bits).push_front(*b);
00967             }
00968         cache_aligned_allocator&lt;chain&gt;().deallocate( old_array, old_size );
00969     }
00970     segment_lock.downgrade_to_reader();
00971 }
00972 
00973 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00974 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source ) {
00975     <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00976         segment&amp; s = source.my_segment[i];
00977         __TBB_ASSERT( !my_segment[i].my_array, <span class="stringliteral">"caller should have cleared"</span> );
00978         <span class="keywordflow">if</span>( s.my_logical_size ) {
00979             segment&amp; d = my_segment[i];
00980             d.allocate_array( s.my_logical_size );
00981             d.my_logical_size = s.my_logical_size;
00982             size_t s_size = s.my_physical_size;
00983             chain* s_array = s.my_array;
00984             chain* d_array = d.my_array;
00985             <span class="keywordflow">for</span>( size_t k=0; k&lt;s_size; ++k )
00986                 <span class="keywordflow">for</span>( node* b = s_array[k].node_list; b; b=b-&gt;next ) {
00987                     __TBB_ASSERT( &amp;get_segment(my_hash_compare.hash( b-&gt;item.first ))==&amp;d, <span class="stringliteral">"hash function changed?"</span> );
00988                     node* b_new = create_node(b-&gt;item.first, &amp;b-&gt;item.second);
00989                     d_array[k].push_front(*b_new); <span class="comment">// hashcode is the same and segment and my_physical sizes are the same</span>
00990                 }
00991         }
00992     }
00993 }
00994 
00995 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00996 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00997 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy(I first, I last) {
00998     <span class="keywordflow">for</span>(; first != last; ++first)
00999         <a class="code" href="a00192.html#a22">insert</a>( *first );
01000 }
01001 
01002 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
01003 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b) {
01004     <span class="keywordflow">if</span>(a.size() != b.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01005     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt;::const_iterator i(a.begin()), i_end(a.end());
01006     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt;::const_iterator j, j_end(b.end());
01007     <span class="keywordflow">for</span>(; i != i_end; ++i) {
01008         j = b.equal_range(i-&gt;first).first;
01009         <span class="keywordflow">if</span>( j == j_end || !(i-&gt;second == j-&gt;second) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01010     }
01011     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01012 }
01013 
01014 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
01015 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b)
01016 {    <span class="keywordflow">return</span> !(a == b); }
01017 
01018 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
01019 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;a, concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;b)
01020 {    a.swap( b ); }
01021 
01022 } <span class="comment">// namespace tbb</span>
01023 
01024 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_hash_map_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
