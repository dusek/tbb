<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_queue.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_queue_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_queue_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "tbb_stddef.h"</span>
00025 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00026 <span class="preprocessor">#include "tbb_allocator.h"</span>
00027 <span class="preprocessor">#include &lt;new&gt;</span>
00028 
00029 <span class="keyword">namespace </span>tbb {
00030 
00031 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A = cache_aligned_allocator&lt;T&gt; &gt; 
00032 <span class="keyword">class </span>concurrent_queue;
00033 
00035 <span class="keyword">namespace </span>internal {
00036 
00037 <span class="keyword">class </span>concurrent_queue_rep;
00038 <span class="keyword">class </span>concurrent_queue_iterator_rep;
00039 <span class="keyword">class </span>concurrent_queue_iterator_base_v3;
00040 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">class </span>concurrent_queue_iterator;
00041 
00043 
<a name="l00045"></a><a class="code" href="a00196.html">00045</a> <span class="keyword">class </span><a class="code" href="a00196.html">concurrent_queue_base_v3</a>: <a class="code" href="a00219.html">no_copy</a> {
00047     concurrent_queue_rep* my_rep;
00048 
00049     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_rep;
00050     <span class="keyword">friend</span> <span class="keyword">struct </span>micro_queue;
00051     <span class="keyword">friend</span> <span class="keyword">class </span>micro_queue_pop_finalizer;
00052     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_iterator_rep;
00053     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>;
00054 <span class="keyword">protected</span>:
<a name="l00056"></a><a class="code" href="a00197.html">00056</a>     <span class="keyword">struct </span><a class="code" href="a00197.html">page</a> {
00057         <a class="code" href="a00197.html">page</a>* next;
00058         <a class="code" href="a00303.html#a25">uintptr</a> mask; 
00059     };
00060 
<a name="l00062"></a><a class="code" href="a00196.html#p0">00062</a>     ptrdiff_t my_capacity;
00063    
<a name="l00065"></a><a class="code" href="a00196.html#p1">00065</a>     size_t items_per_page;
00066 
<a name="l00068"></a><a class="code" href="a00196.html#p2">00068</a>     size_t item_size;
00069 
00070 <span class="keyword">private</span>:
00071     <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( <a class="code" href="a00197.html">page</a>&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) = 0;
00072     <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, <a class="code" href="a00197.html">page</a>&amp; src, size_t index ) = 0;
00073 <span class="keyword">protected</span>:
00074     __TBB_EXPORTED_METHOD <a class="code" href="a00196.html">concurrent_queue_base_v3</a>( size_t item_size );
00075     <span class="keyword">virtual</span> __TBB_EXPORTED_METHOD ~<a class="code" href="a00196.html">concurrent_queue_base_v3</a>();
00076 
00078     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_push( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00079 
00081     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_pop( <span class="keywordtype">void</span>* dst );
00082 
00084     <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_push_if_not_full( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00085 
00087 
00088     <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_pop_if_present( <span class="keywordtype">void</span>* dst );
00089 
00091     ptrdiff_t __TBB_EXPORTED_METHOD internal_size() <span class="keyword">const</span>;
00092 
00094     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_set_capacity( ptrdiff_t capacity, size_t element_size );
00095 
00097     <span class="keyword">virtual</span> <a class="code" href="a00197.html">page</a> *allocate_page() = 0;
00098 
00100     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( <a class="code" href="a00197.html">page</a> *p ) = 0;
00101 
00103     <span class="comment">/* note that the name may be misleading, but it remains so due to a historical accident. */</span>
00104     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_finish_clear() ;
00105 
00107     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_throw_exception() <span class="keyword">const</span>;
00108 };
00109 
00110 <span class="keyword">typedef</span> <a class="code" href="a00196.html">concurrent_queue_base_v3</a> <a class="code" href="a00196.html">concurrent_queue_base</a> ;
00111 
00113 
<a name="l00114"></a><a class="code" href="a00199.html">00114</a> <span class="keyword">class </span><a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a> {
00116 
00117     concurrent_queue_iterator_rep* my_rep;
00118 
00119     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00120     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="a00198.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00198.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00121 
00122     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00123     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> <a class="code" href="a00198.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00198.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00124 <span class="keyword">protected</span>:
<a name="l00126"></a><a class="code" href="a00199.html#p0">00126</a>     <span class="keyword">mutable</span> <span class="keywordtype">void</span>* my_item;
00127 
<a name="l00129"></a><a class="code" href="a00199.html#b0">00129</a>     <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>() : my_rep(NULL), my_item(NULL) {}
00130 
<a name="l00132"></a><a class="code" href="a00199.html#b1">00132</a>     <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>&amp; i ) : my_rep(NULL), my_item(NULL) {
00133         assign(i);
00134     }
00135 
00137     __TBB_EXPORTED_METHOD <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue );
00138 
00140     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD assign( <span class="keyword">const</span> <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>&amp; i );
00141 
00143     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD advance();
00144 
00146     __TBB_EXPORTED_METHOD ~<a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>();
00147 };
00148 
00149 <span class="keyword">typedef</span> concurrent_queue_iterator_base_v3 concurrent_queue_iterator_base;
00150 
00152 
00154 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
<a name="l00155"></a><a class="code" href="a00198.html">00155</a> <span class="keyword">class </span><a class="code" href="a00198.html">concurrent_queue_iterator</a>: <span class="keyword">public</span> <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a> {
00156 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00157 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
00158     <span class="keyword">friend</span> class ::tbb::concurrent_queue;
00159 <span class="preprocessor">#else</span>
00160 <span class="preprocessor"></span><span class="keyword">public</span>: <span class="comment">// workaround for MSVC</span>
00161 <span class="preprocessor">#endif </span>
00162 <span class="preprocessor"></span>
<a name="l00163"></a><a class="code" href="a00198.html#a0">00163</a>     <a class="code" href="a00198.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue ) :
00164         <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>(queue)
00165     {
00166     }
00167 <span class="keyword">public</span>:
00168     <a class="code" href="a00198.html">concurrent_queue_iterator</a>() {}
00169 
<a name="l00172"></a><a class="code" href="a00198.html#a2">00172</a>     <a class="code" href="a00198.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> <a class="code" href="a00198.html">concurrent_queue_iterator&lt;Container,typename Container::value_type&gt;</a>&amp; other ) :
00173         <a class="code" href="a00199.html">concurrent_queue_iterator_base_v3</a>(other)
00174     {}
00175 
<a name="l00177"></a><a class="code" href="a00198.html#a3">00177</a>     <a class="code" href="a00198.html">concurrent_queue_iterator</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00198.html">concurrent_queue_iterator</a>&amp; other ) {
00178         assign(other);
00179         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00180     }
00181 
<a name="l00183"></a><a class="code" href="a00198.html#a4">00183</a>     Value&amp; operator*()<span class="keyword"> const </span>{
00184         <span class="keywordflow">return</span> *static_cast&lt;Value*&gt;(my_item);
00185     }
00186 
00187     Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00188 
<a name="l00190"></a><a class="code" href="a00198.html#a6">00190</a>     <a class="code" href="a00198.html">concurrent_queue_iterator</a>&amp; operator++() {
00191         advance();
00192         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00193     }
00194 
<a name="l00196"></a><a class="code" href="a00198.html#a7">00196</a>     Value* operator++(<span class="keywordtype">int</span>) {
00197         Value* result = &amp;operator*();
00198         operator++();
00199         <span class="keywordflow">return</span> result;
00200     }
00201 }; <span class="comment">// concurrent_queue_iterator</span>
00202 
00203 
00204 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00205 <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00206     <span class="keywordflow">return</span> i.my_item==j.my_item;
00207 }
00208 
00209 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00210 <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00211     <span class="keywordflow">return</span> i.my_item!=j.my_item;
00212 }
00213 
00214 } <span class="comment">// namespace internal;</span>
00215 
00217 
00219 
00222 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00223"></a><a class="code" href="a00195.html">00223</a> <span class="keyword">class </span><a class="code" href="a00195.html">concurrent_queue</a>: <span class="keyword">public</span> internal::concurrent_queue_base_v3 {
00224     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00198.html">internal::concurrent_queue_iterator</a>;
00225 
00227     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;char&gt;::other page_allocator_type;
00228     page_allocator_type my_allocator;
00229 
00231     <span class="keyword">class </span>destroyer {
00232         T&amp; my_value;
00233     <span class="keyword">public</span>:
00234         destroyer( T&amp; value ) : my_value(value) {}
00235         ~destroyer() {my_value.~T();}          
00236     };
00237 
00238     T&amp; get_ref( page&amp; page, size_t index ) {
00239         __TBB_ASSERT( index&lt;items_per_page, NULL );
00240         <span class="keywordflow">return</span> static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;page+1))[index];
00241     }
00242 
00243     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( page&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) {
00244         <span class="keyword">new</span>( &amp;get_ref(dst,index) ) T(*static_cast&lt;const T*&gt;(src)); 
00245     }
00246 
00247     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, page&amp; src, size_t index ) {
00248         T&amp; from = get_ref(src,index);
00249         destroyer d(from);
00250         *static_cast&lt;T*&gt;(dst) = from;
00251     }
00252 
00253     <span class="comment">/*overide*/</span> <span class="keyword">virtual</span> page *allocate_page() {
00254         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00255         page *p = reinterpret_cast&lt;page*&gt;(my_allocator.allocate( n ));
00256         <span class="keywordflow">if</span>( !p ) internal_throw_exception(); 
00257         <span class="keywordflow">return</span> p;
00258     }
00259     
00260     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( page *p ) {
00261         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00262         my_allocator.deallocate( reinterpret_cast&lt;char*&gt;(p), n );
00263     }
00264 
00265 <span class="keyword">public</span>:
<a name="l00267"></a><a class="code" href="a00195.html#w0">00267</a>     <span class="keyword">typedef</span> T value_type;
00268 
<a name="l00270"></a><a class="code" href="a00195.html#w1">00270</a>     <span class="keyword">typedef</span> A allocator_type;
00271 
<a name="l00273"></a><a class="code" href="a00195.html#w2">00273</a>     <span class="keyword">typedef</span> T&amp; reference;
00274 
<a name="l00276"></a><a class="code" href="a00195.html#w3">00276</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;
00277 
00279 
<a name="l00281"></a><a class="code" href="a00195.html#w4">00281</a>     <span class="keyword">typedef</span> std::ptrdiff_t size_type;
00282 
<a name="l00284"></a><a class="code" href="a00195.html#w5">00284</a>     <span class="keyword">typedef</span> std::ptrdiff_t difference_type;
00285 
<a name="l00287"></a><a class="code" href="a00195.html#a0">00287</a>     <a class="code" href="a00195.html">concurrent_queue</a>(<span class="keyword">const</span> allocator_type  &amp;a = allocator_type()) : 
00288         concurrent_queue_base_v3( sizeof(T) )
00289             , my_allocator( a )
00290     {
00291     }
00292 
00294     ~<a class="code" href="a00195.html">concurrent_queue</a>();
00295 
<a name="l00297"></a><a class="code" href="a00195.html#a2">00297</a>     <span class="keywordtype">void</span> push( <span class="keyword">const</span> T&amp; source ) {
00298         internal_push( &amp;source );
00299     }
00300 
00302 
<a name="l00303"></a><a class="code" href="a00195.html#a3">00303</a>     <span class="keywordtype">void</span> pop( T&amp; destination ) {
00304         internal_pop( &amp;destination );
00305     }
00306 
00308 
<a name="l00310"></a><a class="code" href="a00195.html#a4">00310</a>     <span class="keywordtype">bool</span> push_if_not_full( <span class="keyword">const</span> T&amp; source ) {
00311         <span class="keywordflow">return</span> internal_push_if_not_full( &amp;source );
00312     }
00313 
00315 
<a name="l00317"></a><a class="code" href="a00195.html#a5">00317</a>     <span class="keywordtype">bool</span> pop_if_present( T&amp; destination ) {
00318         <span class="keywordflow">return</span> internal_pop_if_present( &amp;destination );
00319     }
00320 
00322 
<a name="l00325"></a><a class="code" href="a00195.html#a6">00325</a>     size_type size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> internal_size();}
00326 
<a name="l00328"></a><a class="code" href="a00195.html#a7">00328</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> size()&lt;=0;}
00329 
<a name="l00331"></a><a class="code" href="a00195.html#a8">00331</a>     size_type capacity()<span class="keyword"> const </span>{
00332         <span class="keywordflow">return</span> my_capacity;
00333     }
00334 
00336 
<a name="l00338"></a><a class="code" href="a00195.html#a9">00338</a>     <span class="keywordtype">void</span> set_capacity( size_type capacity ) {
00339         internal_set_capacity( capacity, <span class="keyword">sizeof</span>(T) );
00340     }
00341 
<a name="l00343"></a><a class="code" href="a00195.html#a10">00343</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00344 
00346     <span class="keywordtype">void</span> clear() ;
00347 
00348     <span class="keyword">typedef</span> <a class="code" href="a00198.html">internal::concurrent_queue_iterator&lt;concurrent_queue,T&gt;</a> iterator;
00349     <span class="keyword">typedef</span> <a class="code" href="a00198.html">internal::concurrent_queue_iterator&lt;concurrent_queue,const T&gt;</a> const_iterator;
00350 
00351     <span class="comment">//------------------------------------------------------------------------</span>
00352     <span class="comment">// The iterators are intended only for debugging.  They are slow and not thread safe.</span>
00353     <span class="comment">//------------------------------------------------------------------------</span>
00354     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>);}
00355     iterator end() {<span class="keywordflow">return</span> iterator();}
00356     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>);}
00357     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator();}
00358     
00359 }; 
00360 
00361 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00362"></a><a class="code" href="a00195.html#a1">00362</a> <a class="code" href="a00195.html">concurrent_queue&lt;T,A&gt;::~concurrent_queue</a>() {
00363     <a class="code" href="a00195.html#a11">clear</a>();
00364     <a class="code" href="a00196.html#b10">internal_finish_clear</a>();
00365 }
00366 
00367 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00368"></a><a class="code" href="a00195.html#a11">00368</a> <span class="keywordtype">void</span> <a class="code" href="a00195.html">concurrent_queue&lt;T,A&gt;::clear</a>() {
00369     <span class="keywordflow">while</span>( !<a class="code" href="a00195.html#a7">empty</a>() ) {
00370         T value;
00371         <a class="code" href="a00196.html#b5">internal_pop_if_present</a>(&amp;value);
00372     }
00373 }
00374 
00375 } <span class="comment">// namespace tbb</span>
00376 
00377 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_queue_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
