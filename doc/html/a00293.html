<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_hash_map.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_hash_map.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_hash_map_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_hash_map_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00025 <span class="preprocessor">#include &lt;iterator&gt;</span>
00026 <span class="preprocessor">#include &lt;utility&gt;</span>      <span class="comment">// Need std::pair from here</span>
00027 <span class="preprocessor">#include "tbb_stddef.h"</span>
00028 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00029 <span class="preprocessor">#include "tbb_allocator.h"</span>
00030 <span class="preprocessor">#include "spin_rw_mutex.h"</span>
00031 <span class="preprocessor">#include "atomic.h"</span>
00032 <span class="preprocessor">#include "aligned_space.h"</span>
00033 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include &lt;typeinfo&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 <span class="keyword">namespace </span>tbb {
00038 
00039 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt; &gt;
00040 <span class="keyword">class </span>concurrent_hash_map;
00041 
00043 <span class="keyword">namespace </span>internal {
<a name="l00045"></a><a class="code" href="a00198.html">00045</a>     <span class="keyword">class </span><a class="code" href="a00198.html">hash_map_base</a> {
00046     <span class="keyword">public</span>:
00047         <span class="comment">// Mutex types for each layer of the container</span>
00048         <span class="keyword">typedef</span> <a class="code" href="a00223.html">spin_rw_mutex</a> <a class="code" href="a00223.html">node_mutex_t</a>;
00049         <span class="keyword">typedef</span> <a class="code" href="a00223.html">spin_rw_mutex</a> <a class="code" href="a00223.html">chain_mutex_t</a>;
00050         <span class="keyword">typedef</span> <a class="code" href="a00223.html">spin_rw_mutex</a> <a class="code" href="a00223.html">segment_mutex_t</a>;
00051 
<a name="l00053"></a><a class="code" href="a00198.html#w3">00053</a>         <span class="keyword">typedef</span> size_t <a class="code" href="a00198.html#w3">hashcode_t</a>;
<a name="l00055"></a><a class="code" href="a00198.html#s0">00055</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment_bits = 6;
<a name="l00057"></a><a class="code" href="a00198.html#s1">00057</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment = size_t(1)&lt;&lt;n_segment_bits; 
<a name="l00059"></a><a class="code" href="a00198.html#s2">00059</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_physical_size = size_t(1)&lt;&lt;(8*<span class="keyword">sizeof</span>(hashcode_t)-n_segment_bits);
00060     };
00061 
00062     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00063     <span class="keyword">class </span><a class="code" href="a00200.html">hash_map_range</a>;
00064 
00065     <span class="keyword">struct </span>hash_map_segment_base {
00067         <a class="code" href="a00223.html">hash_map_base::segment_mutex_t</a> my_mutex;
00068 
00069         <span class="comment">// Number of nodes</span>
00070         <a class="code" href="a00168.html">atomic&lt;size_t&gt;</a> my_logical_size;
00071 
00072         <span class="comment">// Size of chains</span>
00074 <span class="comment"></span>        size_t my_physical_size;
00075 
00077 
00078         <span class="keywordtype">bool</span> internal_grow_predicate() <span class="keyword">const</span>;
00079     };
00080 
00082 
00084     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
<a name="l00085"></a><a class="code" href="a00199.html">00085</a>     <span class="keyword">class </span><a class="code" href="a00199.html">hash_map_iterator</a>
00086 #if defined(_WIN64) &amp;&amp; defined(_MSC_VER) 
00087         <span class="comment">// Ensure that Microsoft's internal template function _Val_type works correctly.</span>
00088         : public std::iterator&lt;std::forward_iterator_tag,Value&gt;
00089 #endif <span class="comment">/* defined(_WIN64) &amp;&amp; defined(_MSC_VER) */</span>
00090     {
00091         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::node node;
00092         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::chain chain;
00093         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::segment segment;
00094 
00096         Container* my_table;
00097 
00099         node* my_node;
00100 
00102         size_t my_array_index;
00103 
00105         size_t my_segment_index;
00106 
00107         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00108         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="a00199.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00199.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00109 
00110         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00111         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> <a class="code" href="a00199.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00199.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00112 
00113         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00114         <span class="keyword">friend</span> ptrdiff_t operator-( <span class="keyword">const</span> <a class="code" href="a00199.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00199.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00115     
00116         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U&gt;
00117         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00199.html">internal::hash_map_iterator</a>;
00118 
00119         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00120         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00200.html">internal::hash_map_range</a>;
00121 
00122         <span class="keywordtype">void</span> advance_to_next_node() {
00123             size_t i = my_array_index+1;
00124             <span class="keywordflow">do</span> {
00125                 segment &amp;s = my_table-&gt;my_segment[my_segment_index];
00126                 <span class="keywordflow">while</span>( i&lt;s.my_physical_size ) {
00127                     my_node = s.my_array[i].node_list;
00128                     <span class="keywordflow">if</span>( my_node ) <span class="keywordflow">goto</span> done;
00129                     ++i;
00130                 }
00131                 i = 0;
00132             } <span class="keywordflow">while</span>( ++my_segment_index&lt;my_table-&gt;n_segment );
00133         done:
00134             my_array_index = i;
00135         }
00136 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00137 <span class="preprocessor"></span>        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00138         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00177.html">tbb::concurrent_hash_map</a>;
00139 <span class="preprocessor">#else</span>
00140 <span class="preprocessor"></span>    <span class="keyword">public</span>: <span class="comment">// workaround</span>
00141 <span class="preprocessor">#endif</span>
00142 <span class="preprocessor"></span>        <a class="code" href="a00199.html">hash_map_iterator</a>( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index=0, node* b=NULL );
00143     <span class="keyword">public</span>:
<a name="l00145"></a><a class="code" href="a00199.html#a0">00145</a>         <a class="code" href="a00199.html">hash_map_iterator</a>() {}
00146         <a class="code" href="a00199.html">hash_map_iterator</a>( <span class="keyword">const</span> <a class="code" href="a00199.html">hash_map_iterator&lt;Container,typename Container::value_type&gt;</a>&amp; other ) :
00147             my_table(other.my_table),
00148             my_node(other.my_node),
00149             my_array_index(other.my_array_index),
00150             my_segment_index(other.my_segment_index)
00151         {}
00152         Value&amp; operator*()<span class="keyword"> const </span>{
00153             __TBB_ASSERT( my_node, <span class="stringliteral">"iterator uninitialized or at end of container?"</span> );
00154             <span class="keywordflow">return</span> my_node-&gt;item;
00155         }
00156         Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00157         hash_map_iterator&amp; operator++();
00158         
<a name="l00160"></a><a class="code" href="a00199.html#a5">00160</a>         Value* operator++(<span class="keywordtype">int</span>) {
00161             Value* result = &amp;operator*();
00162             operator++();
00163             <span class="keywordflow">return</span> result;
00164         }
00165 
00166         <span class="comment">// STL support</span>
00167 
00168         <span class="keyword">typedef</span> ptrdiff_t difference_type;
00169         <span class="keyword">typedef</span> Value value_type;
00170         <span class="keyword">typedef</span> Value* pointer;
00171         <span class="keyword">typedef</span> Value&amp; reference;
00172         <span class="keyword">typedef</span> <span class="keyword">const</span> Value&amp; const_reference;
00173         <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;
00174     };
00175 
00176     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00177     hash_map_iterator&lt;Container,Value&gt;::hash_map_iterator( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index, node* b ) : 
00178         my_table(const_cast&lt;Container*&gt;(&amp;table)),
00179         my_node(b),
00180         my_array_index(array_index),
00181         my_segment_index(segment_index)
00182     {
00183         <span class="keywordflow">if</span>( segment_index&lt;my_table-&gt;n_segment ) {
00184             <span class="keywordflow">if</span>( !my_node ) {
00185                 segment &amp;s = my_table-&gt;my_segment[segment_index];
00186                 chain* first_chain = s.my_array;
00187                 <span class="keywordflow">if</span>( first_chain &amp;&amp; my_array_index &lt; s.my_physical_size)
00188                     my_node = first_chain[my_array_index].node_list;
00189             }
00190             <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00191         }
00192     }
00193 
00194     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00195     hash_map_iterator&lt;Container,Value&gt;&amp; hash_map_iterator&lt;Container,Value&gt;::operator++() {
00196         my_node=my_node-&gt;next;
00197         <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00198         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00199     }
00200 
00201     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00202     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00203         <span class="keywordflow">return</span> i.<a class="code" href="a00199.html#r1">my_node</a>==j.<a class="code" href="a00199.html#r1">my_node</a>;
00204     }
00205 
00206     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00207     <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00208         <span class="keywordflow">return</span> i.<a class="code" href="a00199.html#r1">my_node</a>!=j.<a class="code" href="a00199.html#r1">my_node</a>;
00209     }
00210 
00212 
00213     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00214"></a><a class="code" href="a00200.html">00214</a>     <span class="keyword">class </span><a class="code" href="a00200.html">hash_map_range</a> {
00215     <span class="keyword">private</span>:
00216         Iterator my_begin;
00217         Iterator my_end;
00218         <span class="keyword">mutable</span> Iterator my_midpoint;
00219         size_t my_grainsize;
00221         <span class="keywordtype">void</span> set_midpoint() <span class="keyword">const</span>;
00222         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00200.html">hash_map_range</a>;
00223     <span class="keyword">public</span>:
<a name="l00225"></a><a class="code" href="a00200.html#w0">00225</a>         <span class="keyword">typedef</span> std::size_t size_type;
00226         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;
00227         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference;
00228         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::const_reference const_reference;
00229         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type;
00230         <span class="keyword">typedef</span> Iterator iterator;
00231 
<a name="l00233"></a><a class="code" href="a00200.html#a0">00233</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin==my_end;}
00234 
<a name="l00236"></a><a class="code" href="a00200.html#a1">00236</a>         <span class="keywordtype">bool</span> is_divisible()<span class="keyword"> const </span>{
00237             <span class="keywordflow">return</span> my_midpoint!=my_end;
00238         }
<a name="l00240"></a><a class="code" href="a00200.html#a2">00240</a>         <a class="code" href="a00200.html">hash_map_range</a>( <a class="code" href="a00200.html">hash_map_range</a>&amp; r, <a class="code" href="a00225.html">split</a> ) : 
00241             my_end(r.my_end),
00242             my_grainsize(r.my_grainsize)
00243         {
00244             r.<a class="code" href="a00200.html#r1">my_end</a> = my_begin = r.<a class="code" href="a00200.html#r2">my_midpoint</a>;
00245             __TBB_ASSERT( my_begin!=my_end, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00246             __TBB_ASSERT( r.<a class="code" href="a00200.html#r0">my_begin</a>!=r.<a class="code" href="a00200.html#r1">my_end</a>, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00247             set_midpoint();
00248             r.<a class="code" href="a00200.html#d0">set_midpoint</a>();
00249         }
00251         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
<a name="l00252"></a><a class="code" href="a00200.html#a3">00252</a>         <a class="code" href="a00200.html">hash_map_range</a>( <a class="code" href="a00200.html">hash_map_range&lt;U&gt;</a>&amp; r) : 
00253             my_begin(r.my_begin),
00254             my_end(r.my_end),
00255             my_midpoint(r.my_midpoint),
00256             my_grainsize(r.my_grainsize)
00257         {}
<a name="l00259"></a><a class="code" href="a00200.html#a4">00259</a>         <a class="code" href="a00200.html">hash_map_range</a>( <span class="keyword">const</span> Iterator&amp; begin_, <span class="keyword">const</span> Iterator&amp; end_, size_type grainsize = 1 ) : 
00260             my_begin(begin_), 
00261             my_end(end_), 
00262             my_grainsize(grainsize) 
00263         {
00264             set_midpoint();
00265             __TBB_ASSERT( grainsize&gt;0, <span class="stringliteral">"grainsize must be positive"</span> );
00266         }
00267         <span class="keyword">const</span> Iterator&amp; begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin;}
00268         <span class="keyword">const</span> Iterator&amp; end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_end;}
<a name="l00270"></a><a class="code" href="a00200.html#a7">00270</a>         size_type grainsize()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_grainsize;}
00271     };
00272 
00273     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00274     <span class="keywordtype">void</span> hash_map_range&lt;Iterator&gt;::set_midpoint()<span class="keyword"> const </span>{
00275         size_t n = my_end.my_segment_index - my_begin.my_segment_index;
00276         <span class="keywordflow">if</span>( n &gt; 1 || (n == 1 &amp;&amp; my_end.my_array_index &gt; my_grainsize/2) ) {
00277             <span class="comment">// Split by groups of segments</span>
00278             my_midpoint = Iterator(*my_begin.my_table,(my_end.my_segment_index+my_begin.my_segment_index+1)/2u);
00279         } <span class="keywordflow">else</span> {
00280             <span class="comment">// Split by groups of nodes</span>
00281             size_t m = my_end.my_array_index-my_begin.my_array_index;
00282             <span class="keywordflow">if</span>( n ) m += my_begin.my_table-&gt;my_segment[my_begin.my_segment_index].my_physical_size;
00283             <span class="keywordflow">if</span>( m &gt; my_grainsize ) {
00284                 my_midpoint = Iterator(*my_begin.my_table,my_begin.my_segment_index,my_begin.my_array_index + m/2u);
00285             } <span class="keywordflow">else</span> {
00286                 my_midpoint = my_end;
00287             }
00288         }
00289         __TBB_ASSERT( my_begin.my_segment_index &lt; my_midpoint.my_segment_index
00290             || (my_begin.my_segment_index == my_midpoint.my_segment_index
00291             &amp;&amp; my_begin.my_array_index &lt;= my_midpoint.my_array_index),
00292             <span class="stringliteral">"my_begin is after my_midpoint"</span> );
00293         __TBB_ASSERT( my_midpoint.my_segment_index &lt; my_end.my_segment_index
00294             || (my_midpoint.my_segment_index == my_end.my_segment_index
00295             &amp;&amp; my_midpoint.my_array_index &lt;= my_end.my_array_index),
00296             <span class="stringliteral">"my_midpoint is after my_end"</span> );
00297         __TBB_ASSERT( my_begin != my_midpoint || my_begin == my_end,
00298             <span class="stringliteral">"[my_begin, my_midpoint) range should not be empty"</span> );
00299     }
00300 } <span class="comment">// namespace internal</span>
00302 <span class="comment"></span>
00304 
00329 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00330"></a><a class="code" href="a00177.html">00330</a> <span class="keyword">class </span><a class="code" href="a00177.html">concurrent_hash_map</a> : <span class="keyword">protected</span> internal::hash_map_base {
00331     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00332     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00199.html">internal::hash_map_iterator</a>;
00333 
00334     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00335     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00200.html">internal::hash_map_range</a>;
00336 
00337     <span class="keyword">struct </span>node;
00338     <span class="keyword">friend</span> <span class="keyword">struct </span>node;
00339     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;node&gt;::other node_allocator_type;
00340 
00341 <span class="keyword">public</span>:
00342     <span class="keyword">class </span><a class="code" href="a00179.html">const_accessor</a>;
00343     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00179.html">const_accessor</a>;
00344     <span class="keyword">class </span><a class="code" href="a00178.html">accessor</a>;
00345 
00346     <span class="keyword">typedef</span> Key key_type;
00347     <span class="keyword">typedef</span> T mapped_type;
00348     <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00349     <span class="keyword">typedef</span> size_t size_type;
00350     <span class="keyword">typedef</span> ptrdiff_t difference_type;
00351     <span class="keyword">typedef</span> value_type *pointer;
00352     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;
00353     <span class="keyword">typedef</span> value_type &amp;reference;
00354     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type &amp;const_reference;
00355     <span class="keyword">typedef</span> <a class="code" href="a00199.html">internal::hash_map_iterator&lt;concurrent_hash_map,value_type&gt;</a> <a class="code" href="a00199.html">iterator</a>;
00356     <span class="keyword">typedef</span> <a class="code" href="a00199.html">internal::hash_map_iterator&lt;concurrent_hash_map,const value_type&gt;</a> <a class="code" href="a00199.html">const_iterator</a>;
00357     <span class="keyword">typedef</span> <a class="code" href="a00200.html">internal::hash_map_range&lt;iterator&gt;</a> <a class="code" href="a00200.html">range_type</a>;
00358     <span class="keyword">typedef</span> <a class="code" href="a00200.html">internal::hash_map_range&lt;const_iterator&gt;</a> <a class="code" href="a00200.html">const_range_type</a>;
00359     <span class="keyword">typedef</span> A allocator_type;
00360 
<a name="l00362"></a><a class="code" href="a00179.html">00362</a>     <span class="keyword">class </span><a class="code" href="a00179.html">const_accessor</a> {
00363         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00177.html">concurrent_hash_map</a>;
00364         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00178.html">accessor</a>;
00365         <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="a00178.html">accessor</a>&amp; ) <span class="keyword">const</span>; <span class="comment">// Deny access</span>
00366         <a class="code" href="a00179.html">const_accessor</a>( <span class="keyword">const</span> <a class="code" href="a00178.html">accessor</a>&amp; );       <span class="comment">// Deny access</span>
00367     <span class="keyword">public</span>:
<a name="l00369"></a><a class="code" href="a00179.html#w0">00369</a>         <span class="keyword">typedef</span> <span class="keyword">const</span> std::pair&lt;const Key,T&gt; value_type;
00370 
<a name="l00372"></a><a class="code" href="a00179.html#a0">00372</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> !my_node;}
00373 
<a name="l00375"></a><a class="code" href="a00179.html#a1">00375</a>         <span class="keywordtype">void</span> <a class="code" href="a00282.html#a40a2">release</a>() {
00376             <span class="keywordflow">if</span>( my_node ) {
00377                 my_lock.release();
00378                 my_node = NULL;
00379             }
00380         }
00381 
<a name="l00383"></a><a class="code" href="a00179.html#a2">00383</a>         const_reference operator*()<span class="keyword"> const </span>{
00384             __TBB_ASSERT( my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00385             <span class="keywordflow">return</span> my_node-&gt;item;
00386         }
00387 
<a name="l00389"></a><a class="code" href="a00179.html#a3">00389</a>         const_pointer operator-&gt;()<span class="keyword"> const </span>{
00390             <span class="keywordflow">return</span> &amp;operator*();
00391         }
00392 
<a name="l00394"></a><a class="code" href="a00179.html#a4">00394</a>         <a class="code" href="a00179.html">const_accessor</a>() : my_node(NULL) {}
00395 
<a name="l00397"></a><a class="code" href="a00179.html#a5">00397</a>         ~<a class="code" href="a00179.html">const_accessor</a>() {
00398             my_node = NULL; <span class="comment">// my_lock.release() is called in scoped_lock destructor</span>
00399         }
00400     <span class="keyword">private</span>:
00401         node* my_node;
00402         node_mutex_t::scoped_lock my_lock;
00403         hashcode_t my_hash;
00404     };
00405 
<a name="l00407"></a><a class="code" href="a00178.html">00407</a>     <span class="keyword">class </span><a class="code" href="a00178.html">accessor</a>: <span class="keyword">public</span> <a class="code" href="a00179.html">const_accessor</a> {
00408     <span class="keyword">public</span>:
<a name="l00410"></a><a class="code" href="a00178.html#w0">00410</a>         <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00411 
<a name="l00413"></a><a class="code" href="a00178.html#a0">00413</a>         reference operator*()<span class="keyword"> const </span>{
00414             __TBB_ASSERT( this-&gt;my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00415             <span class="keywordflow">return</span> this-&gt;my_node-&gt;item;
00416         }
00417 
<a name="l00419"></a><a class="code" href="a00178.html#a1">00419</a>         pointer operator-&gt;()<span class="keyword"> const </span>{
00420             <span class="keywordflow">return</span> &amp;operator*();
00421         }       
00422     };
00423 
<a name="l00425"></a><a class="code" href="a00177.html#a0">00425</a>     <a class="code" href="a00177.html">concurrent_hash_map</a>(<span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00426         : my_allocator(a)
00427 
00428     {
00429         initialize();
00430     }
00431 
<a name="l00433"></a><a class="code" href="a00177.html#a1">00433</a>     <a class="code" href="a00177.html">concurrent_hash_map</a>( <span class="keyword">const</span> <a class="code" href="a00177.html">concurrent_hash_map</a>&amp; table, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00434         : my_allocator(a)
00435     {
00436         initialize();
00437         internal_copy(table);
00438     }
00439 
00441     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00442"></a><a class="code" href="a00177.html#a2">00442</a>     <a class="code" href="a00177.html">concurrent_hash_map</a>(I first, I last, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00443         : my_allocator(a)
00444     {
00445         initialize();
00446         internal_copy(first, last);
00447     }
00448 
<a name="l00450"></a><a class="code" href="a00177.html#a3">00450</a>     <a class="code" href="a00177.html">concurrent_hash_map</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00177.html">concurrent_hash_map</a>&amp; table ) {
00451         <span class="keywordflow">if</span>( <span class="keyword">this</span>!=&amp;table ) {
00452             clear();
00453             internal_copy(table);
00454         } 
00455         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00456     }
00457 
00458 
00460     <span class="keywordtype">void</span> clear();
00461 
00463     ~<a class="code" href="a00177.html">concurrent_hash_map</a>();
00464 
00465     <span class="comment">//------------------------------------------------------------------------</span>
00466     <span class="comment">// Parallel algorithm support</span>
00467     <span class="comment">//------------------------------------------------------------------------</span>
00468     range_type range( size_type grainsize=1 ) {
00469         <span class="keywordflow">return</span> range_type( begin(), end(), grainsize );
00470     }
00471     const_range_type range( size_type grainsize=1 )<span class="keyword"> const </span>{
00472         <span class="keywordflow">return</span> const_range_type( begin(), end(), grainsize );
00473     }
00474 
00475     <span class="comment">//------------------------------------------------------------------------</span>
00476     <span class="comment">// STL support - not thread-safe methods</span>
00477     <span class="comment">//------------------------------------------------------------------------</span>
00478     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,0);}
00479     iterator end() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,n_segment);}
00480     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,0);}
00481     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,n_segment);}
00482     std::pair&lt;iterator, iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key ) { <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00483     std::pair&lt;const_iterator, const_iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00484     
00486 
00488     size_type size() <span class="keyword">const</span>;
00489 
00491     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
00492 
<a name="l00494"></a><a class="code" href="a00177.html#a16">00494</a>     size_type max_size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> (~size_type(0))/<span class="keyword">sizeof</span>(node);}
00495 
<a name="l00497"></a><a class="code" href="a00177.html#a17">00497</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00498 
00500     <span class="keywordtype">void</span> swap(<a class="code" href="a00177.html">concurrent_hash_map</a> &amp;table);
00501 
00502     <span class="comment">//------------------------------------------------------------------------</span>
00503     <span class="comment">// concurrent map operations</span>
00504     <span class="comment">//------------------------------------------------------------------------</span>
00505 
<a name="l00507"></a><a class="code" href="a00177.html#a19">00507</a>     size_type count( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00508         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(NULL, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00509     }
00510 
00512 
<a name="l00513"></a><a class="code" href="a00177.html#a20">00513</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00179.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00514         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00515     }
00516 
00518 
<a name="l00519"></a><a class="code" href="a00177.html#a21">00519</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00178.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00520         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00521     }
00522         
00524 
<a name="l00525"></a><a class="code" href="a00177.html#a22">00525</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00179.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00526         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00527     }
00528 
00530 
<a name="l00531"></a><a class="code" href="a00177.html#a23">00531</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00178.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00532         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00533     }
00534 
00536 
<a name="l00537"></a><a class="code" href="a00177.html#a24">00537</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00179.html">const_accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00538         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00539     }
00540 
00542 
<a name="l00543"></a><a class="code" href="a00177.html#a25">00543</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00178.html">accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00544         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">true</span>, &amp;value.second );
00545     }
00546 
00548 
<a name="l00549"></a><a class="code" href="a00177.html#a26">00549</a>     <span class="keywordtype">bool</span> insert( <span class="keyword">const</span> value_type&amp; value ) {
00550         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(NULL, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00551     }
00552 
00554     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00555"></a><a class="code" href="a00177.html#a27">00555</a>     <span class="keywordtype">void</span> insert(I first, I last) {
00556         <span class="keywordflow">for</span>(; first != last; ++first)
00557             insert( *first );
00558     }
00559 
00561 
00562     <span class="keywordtype">bool</span> erase( <span class="keyword">const</span> Key&amp; key );
00563 
00565 
<a name="l00566"></a><a class="code" href="a00177.html#a29">00566</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00179.html">const_accessor</a>&amp; item_accessor ) {
00567         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">true</span> );
00568     }
00569 
00571 
<a name="l00572"></a><a class="code" href="a00177.html#a30">00572</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00178.html">accessor</a>&amp; item_accessor ) {
00573         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">false</span> );
00574     }
00575 
00576 <span class="keyword">private</span>:
00578     <span class="keyword">struct </span>node {
00580         node* next;
00581         node_mutex_t <a class="code" href="a00202.html">mutex</a>;
00582         value_type item;
00583         node( <span class="keyword">const</span> Key&amp; key ) : item(key, T()) {}
00584         node( <span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T&amp; t ) : item(key, t) {}
00585         <span class="comment">// exception-safe allocation, see C++ Standard 2003, clause 5.3.4p17</span>
00586         <span class="keywordtype">void</span>* operator new( size_t size, node_allocator_type&amp; a ) {
00587             <span class="keywordtype">void</span> *ptr = a.allocate(1);
00588             <span class="keywordflow">if</span>(!ptr) <span class="keywordflow">throw</span> std::bad_alloc();
00589             <span class="keywordflow">return</span> ptr;
00590         }
00591         <span class="comment">// match placement-new form above to be called if exception thrown in constructor</span>
00592         <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* ptr, node_allocator_type&amp; a ) {<span class="keywordflow">return</span> a.deallocate(static_cast&lt;node*&gt;(ptr),1); }
00593     };
00594 
00595     <span class="keyword">struct </span>chain;
00596     <span class="keyword">friend</span> <span class="keyword">struct </span>chain;
00597 
00599 
00600     <span class="keyword">struct </span>chain {
00601         <span class="keywordtype">void</span> push_front( node&amp; b ) {
00602             b.next = node_list;
00603             node_list = &amp;b;
00604         }
00605         chain_mutex_t mutex;
00606         node* node_list;
00607     };
00608 
00609     <span class="keyword">struct </span>segment;
00610     <span class="keyword">friend</span> <span class="keyword">struct </span>segment;
00611 
00613 
00615     <span class="keyword">struct </span>segment: internal::hash_map_segment_base {
00616 <span class="preprocessor">#if TBB_DO_ASSERT</span>
00617 <span class="preprocessor"></span>        ~segment() {
00618             __TBB_ASSERT( !my_array, <span class="stringliteral">"should have been cleared earlier"</span> );
00619         }
00620 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_ASSERT */</span>
00621 
00622         <span class="comment">// Pointer to array of chains</span>
00623         chain* my_array;
00624 
00625         <span class="comment">// Get chain in this segment that corresponds to given hash code.</span>
00626         chain&amp; get_chain( hashcode_t hashcode, size_t n_segment_bits ) {
00627             <span class="keywordflow">return</span> my_array[(hashcode&gt;&gt;n_segment_bits)&amp;(my_physical_size-1)];
00628         }
00629      
00631 
00633         <span class="keywordtype">void</span> allocate_array( size_t new_size ) {
00634             size_t n=(internal::NFS_GetLineSize()+<span class="keyword">sizeof</span>(chain)-1)/<span class="keyword">sizeof</span>(chain);
00635             __TBB_ASSERT((n&amp;(n-1))==0, NULL);
00636             <span class="keywordflow">while</span>( n&lt;new_size ) n&lt;&lt;=1;
00637             chain* array = cache_aligned_allocator&lt;chain&gt;().allocate( n );
00638             <span class="comment">// storing earlier might help overcome false positives of in deducing "bool grow" in concurrent threads</span>
00639             __TBB_store_with_release(my_physical_size, n);
00640             memset( array, 0, n*<span class="keyword">sizeof</span>(chain) );
00641             my_array = array;
00642         }
00643     };
00644 
00645     segment&amp; get_segment( hashcode_t hashcode ) {
00646         <span class="keywordflow">return</span> my_segment[hashcode&amp;(n_segment-1)];
00647     }
00648 
00649     node_allocator_type my_allocator;
00650 
00651     HashCompare my_hash_compare;
00652 
00653     segment* my_segment;
00654 
00655     node* create_node(<span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T* t) {
00656         <span class="comment">// exception-safe allocation and construction</span>
00657         <span class="keywordflow">if</span>(t) <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key, *t);
00658         <span class="keywordflow">else</span>  <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key);
00659     }
00660 
00661     <span class="keywordtype">void</span> delete_node(node* b) {
00662         my_allocator.destroy(b);
00663         my_allocator.deallocate(b, 1);
00664     }
00665 
00666     node* search_list( <span class="keyword">const</span> Key&amp; key, chain&amp; c )<span class="keyword"> const </span>{
00667         node* b = c.node_list;
00668         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first) )
00669             b = b-&gt;next;
00670         <span class="keywordflow">return</span> b;
00671     }
00673     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00674     std::pair&lt;I, I&gt; internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end ) <span class="keyword">const</span>;
00675 
00677     <span class="keywordtype">bool</span> exclude( const_accessor&amp; item_accessor, <span class="keywordtype">bool</span> readonly );
00678 
00680     <span class="keywordtype">void</span> grow_segment( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s );
00681 
00683     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00684     <span class="keywordtype">bool</span> lookup( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t );
00685 
00687     <span class="keywordtype">void</span> initialize() {
00688         my_segment = cache_aligned_allocator&lt;segment&gt;().allocate(n_segment);
00689         memset( my_segment, 0, <span class="keyword">sizeof</span>(segment)*n_segment );
00690      }
00691 
00693     <span class="keywordtype">void</span> internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source );
00694 
00695     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00696     <span class="keywordtype">void</span> internal_copy(I first, I last);
00697 };
00698 
00699 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00700"></a><a class="code" href="a00177.html#a5">00700</a> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::~concurrent_hash_map</a>() {
00701     <a class="code" href="a00177.html#a4">clear</a>();
00702     <a class="code" href="a00175.html">cache_aligned_allocator&lt;segment&gt;</a>().deallocate( my_segment, n_segment );
00703 }
00704 
00705 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00706"></a><a class="code" href="a00177.html#a14">00706</a> <span class="keyword">typename</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a>::size_type <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::size</a>()<span class="keyword"> const </span>{
00707     size_type result = 0;
00708     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00709         result += my_segment[k].my_logical_size;
00710     <span class="keywordflow">return</span> result;
00711 }
00712 
00713 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00714"></a><a class="code" href="a00177.html#a15">00714</a> <span class="keywordtype">bool</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::empty</a>()<span class="keyword"> const </span>{
00715     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00716         <span class="keywordflow">if</span>( my_segment[k].my_logical_size )
00717             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00718     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00719 }
00720 
00721 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00722 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00723 <span class="keywordtype">bool</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::lookup</a>( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t ) {
00724     <span class="keywordflow">if</span>( result <span class="comment">/*&amp;&amp; result-&gt;my_node -- checked in release() */</span> )
00725         result-&gt;release();
00726     <span class="keyword">const</span> hashcode_t h = my_hash_compare.hash( key );
00727     segment&amp; s = get_segment(h);
00728 restart:
00729     <span class="keywordtype">bool</span> return_value = <span class="keyword">false</span>;
00730     <span class="comment">// first check in double-check sequence</span>
00731 <span class="preprocessor">#if TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT</span>
00732 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.internal_grow_predicate();
00733 <span class="preprocessor">#else</span>
00734 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.my_logical_size &gt;= s.my_physical_size
00735         &amp;&amp; s.my_physical_size &lt; max_physical_size; <span class="comment">// check whether there are free bits</span>
00736 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT */</span>
00737     segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span>grow );
00738     <span class="keywordflow">if</span>( grow ) { <span class="comment">// Load factor is too high  </span>
00739         grow_segment( segment_lock, s );
00740     }
00741     <span class="keywordflow">if</span>( !s.my_array ) {
00742         __TBB_ASSERT( !op_insert, NULL );
00743         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00744     }
00745     __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00746     chain&amp; c = s.get_chain( h, n_segment_bits );
00747     chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00748 
00749     node* b = search_list( key, c );
00750     <span class="keywordflow">if</span>( op_insert ) {
00751         <span class="keywordflow">if</span>( !b ) {
00752             b = create_node(key, t);
00753             <span class="comment">// Search failed</span>
00754             <span class="keywordflow">if</span>( !chain_lock.upgrade_to_writer() ) {
00755                 <span class="comment">// Rerun search_list, in case another thread inserted the item during the upgrade.</span>
00756                 node* b_temp = search_list( key, c );
00757                 <span class="keywordflow">if</span>( b_temp ) { <span class="comment">// unfortunately, it did</span>
00758                     chain_lock.downgrade_to_reader();
00759                     delete_node( b );
00760                     b = b_temp;
00761                     <span class="keywordflow">goto</span> done;
00762                 }
00763             }
00764             ++s.my_logical_size; <span class="comment">// we can't change it earlier due to correctness of size() and exception safety of equal()</span>
00765             return_value = <span class="keyword">true</span>;
00766             c.push_front( *b );
00767         }
00768     } <span class="keywordflow">else</span> { <span class="comment">// find or count</span>
00769         <span class="keywordflow">if</span>( !b )      <span class="keywordflow">return</span> <span class="keyword">false</span>;
00770         return_value = <span class="keyword">true</span>;
00771     }
00772 done:
00773     <span class="keywordflow">if</span>( !result ) <span class="keywordflow">return</span> return_value;
00774     <span class="keywordflow">if</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) ) {
00775         <span class="comment">// we are unlucky, prepare for longer wait</span>
00776         internal::AtomicBackoff trials;
00777         <span class="keywordflow">do</span> {
00778             <span class="keywordflow">if</span>( !trials.bounded_pause() ) {
00779                 <span class="comment">// the wait takes really long, restart the operation</span>
00780                 chain_lock.release(); segment_lock.release();
00781                 __TBB_Yield();
00782                 <span class="keywordflow">goto</span> restart;
00783             }
00784         } <span class="keywordflow">while</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) );
00785     }
00786     result-&gt;my_node = b;
00787     result-&gt;my_hash = h;
00788     <span class="keywordflow">return</span> return_value;
00789 }
00790 
00791 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00792 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00793 std::pair&lt;I, I&gt; concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end )<span class="keyword"> const </span>{
00794     <a class="code" href="a00198.html#w3">hashcode_t</a> h = my_hash_compare.hash( key );
00795     size_t segment_index = h&amp;(<a class="code" href="a00198.html#s1">n_segment</a>-1);
00796     segment&amp; s = my_segment[segment_index ];
00797     size_t chain_index = (h&gt;&gt;n_segment_bits)&amp;(s.my_physical_size-1);
00798     <span class="keywordflow">if</span>( !s.my_array )
00799         <span class="keywordflow">return</span> std::make_pair(end, end);
00800     chain&amp; c = s.my_array[chain_index];
00801     node* b = search_list( key, c );
00802     <span class="keywordflow">if</span>( !b )
00803         <span class="keywordflow">return</span> std::make_pair(end, end);
00804     iterator lower(*<span class="keyword">this</span>, segment_index, chain_index, b), upper(lower);
00805     <span class="keywordflow">return</span> std::make_pair(lower, ++upper);
00806 }
00807 
00808 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00809"></a><a class="code" href="a00177.html#a28">00809</a> <span class="keywordtype">bool</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::erase</a>( <span class="keyword">const</span> Key &amp;key ) {
00810     hashcode_t h = my_hash_compare.hash( key );
00811     segment&amp; s = get_segment( h );
00812     node* b;
00813     {
00814         <span class="keywordtype">bool</span> chain_locked_for_write = <span class="keyword">false</span>;
00815         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00816         <span class="keywordflow">if</span>( !s.my_array ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00817         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00818         chain&amp; c = s.get_chain( h, n_segment_bits );
00819         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00820     search:
00821         node** p = &amp;c.node_list;
00822         b = *p;
00823         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first ) ) {
00824             p = &amp;b-&gt;next;
00825             b = *p;
00826         }
00827         <span class="keywordflow">if</span>( !b ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00828         <span class="keywordflow">if</span>( !chain_locked_for_write &amp;&amp; !chain_lock.upgrade_to_writer() ) {
00829             chain_locked_for_write = <span class="keyword">true</span>;
00830             <span class="keywordflow">goto</span> search;
00831         }
00832         *p = b-&gt;next;
00833         --s.my_logical_size;
00834     }
00835     {
00836         node_mutex_t::scoped_lock item_locker( b-&gt;mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00837     }
00838     <span class="comment">// note: there should be no threads pretending to acquire this mutex again, do not try to upgrade const_accessor!</span>
00839     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00840     <span class="keywordflow">return</span> <span class="keyword">true</span>;        
00841 }
00842 
00843 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00844 <span class="keywordtype">bool</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::exclude</a>( const_accessor &amp;item_accessor, <span class="keywordtype">bool</span> readonly ) {
00845     __TBB_ASSERT( item_accessor.my_node, NULL );
00846     <span class="keyword">const</span> hashcode_t h = item_accessor.my_hash;
00847     node *<span class="keyword">const</span> b = item_accessor.my_node;
00848     item_accessor.my_node = NULL; <span class="comment">// we ought release accessor anyway</span>
00849     segment&amp; s = get_segment( h );
00850     {
00851         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00852         __TBB_ASSERT( s.my_array, NULL );
00853         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00854         chain&amp; c = s.get_chain( h, n_segment_bits );
00855         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00856         node** p = &amp;c.node_list;
00857         <span class="keywordflow">while</span>( *p &amp;&amp; *p != b )
00858             p = &amp;(*p)-&gt;next;
00859         <span class="keywordflow">if</span>( !*p ) { <span class="comment">// someone else was the first</span>
00860             item_accessor.my_lock.release();
00861             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00862         }
00863         __TBB_ASSERT( *p == b, NULL );
00864         *p = b-&gt;next;
00865         --s.my_logical_size;
00866     }
00867     <span class="keywordflow">if</span>( readonly ) <span class="comment">// need to get exclusive lock</span>
00868         item_accessor.my_lock.upgrade_to_writer(); <span class="comment">// return value means nothing here</span>
00869     item_accessor.my_lock.release();
00870     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00871     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00872 }
00873 
00874 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00875"></a><a class="code" href="a00177.html#a18">00875</a> <span class="keywordtype">void</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::swap</a>(<a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a> &amp;table) {
00876     std::swap(this-&gt;my_allocator, table.<a class="code" href="a00177.html#r0">my_allocator</a>);
00877     std::swap(this-&gt;my_hash_compare, table.<a class="code" href="a00177.html#r1">my_hash_compare</a>);
00878     std::swap(this-&gt;my_segment, table.<a class="code" href="a00177.html#r2">my_segment</a>);
00879 }
00880 
00881 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00882"></a><a class="code" href="a00177.html#a4">00882</a> <span class="keywordtype">void</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::clear</a>() {
00883 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00884 <span class="preprocessor"></span>    size_t total_physical_size = 0, min_physical_size = size_t(-1L), max_physical_size = 0; <span class="comment">//&lt; usage statistics</span>
00885     <span class="keyword">static</span> <span class="keywordtype">bool</span> reported = <span class="keyword">false</span>;
00886 <span class="preprocessor">#endif</span>
00887 <span class="preprocessor"></span>    <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00888         segment&amp; s = my_segment[i];
00889         size_t n = s.my_physical_size;
00890         <span class="keywordflow">if</span>( chain* array = s.my_array ) {
00891             s.my_array = NULL;
00892             s.my_physical_size = 0;
00893             s.my_logical_size = 0;
00894             <span class="keywordflow">for</span>( size_t j=0; j&lt;n; ++j ) {
00895                 <span class="keywordflow">while</span>( node* b = array[j].node_list ) {
00896                     array[j].node_list = b-&gt;next;
00897                     delete_node(b);
00898                 }
00899             }
00900             <a class="code" href="a00175.html">cache_aligned_allocator&lt;chain&gt;</a>().deallocate( array, n );
00901         }
00902 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00903 <span class="preprocessor"></span>        total_physical_size += n;
00904         <span class="keywordflow">if</span>(min_physical_size &gt; n) min_physical_size = n;
00905         <span class="keywordflow">if</span>(max_physical_size &lt; n) max_physical_size = n;
00906     }
00907     <span class="keywordflow">if</span>( !reported
00908         &amp;&amp; ( (total_physical_size &gt;= n_segment*48 &amp;&amp; min_physical_size &lt; total_physical_size/n_segment/2)
00909          || (total_physical_size &gt;= n_segment*128 &amp;&amp; max_physical_size &gt; total_physical_size/n_segment*2) ) )
00910     {
00911         reported = <span class="keyword">true</span>;
00912         internal::runtime_warning(
00913             <span class="stringliteral">"Performance is not optimal because the hash function produces bad randomness in lower bits in %s"</span>,
00914             <span class="keyword">typeid</span>(*this).name() );
00915 <span class="preprocessor">#endif</span>
00916 <span class="preprocessor"></span>    }
00917 }
00918 
00919 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00920 <span class="keywordtype">void</span> <a class="code" href="a00177.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::grow_segment</a>( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s ) {
00921     <span class="comment">// Following is second check in a double-check.</span>
00922     <span class="keywordflow">if</span>( s.my_logical_size &gt;= s.my_physical_size ) {
00923         chain* old_array = s.my_array;
00924         size_t old_size = s.my_physical_size;
00925         s.allocate_array( s.my_logical_size+1 );
00926         <span class="keywordflow">for</span>( size_t k=0; k&lt;old_size; ++k )
00927             <span class="keywordflow">while</span>( node* b = old_array[k].node_list ) {
00928                 old_array[k].node_list = b-&gt;next;
00929                 hashcode_t h = my_hash_compare.hash( b-&gt;item.first );
00930                 __TBB_ASSERT( &amp;get_segment(h)==&amp;s, <span class="stringliteral">"hash function changed?"</span> );
00931                 s.get_chain(h,n_segment_bits).push_front(*b);
00932             }
00933         cache_aligned_allocator&lt;chain&gt;().deallocate( old_array, old_size );
00934     }
00935     segment_lock.downgrade_to_reader();
00936 }
00937 
00938 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00939 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source ) {
00940     <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00941         segment&amp; s = source.my_segment[i];
00942         __TBB_ASSERT( !my_segment[i].my_array, <span class="stringliteral">"caller should have cleared"</span> );
00943         <span class="keywordflow">if</span>( s.my_logical_size ) {
00944             segment&amp; d = my_segment[i];
00945             d.allocate_array( s.my_logical_size );
00946             d.my_logical_size = s.my_logical_size;
00947             size_t s_size = s.my_physical_size;
00948             chain* s_array = s.my_array;
00949             chain* d_array = d.my_array;
00950             <span class="keywordflow">for</span>( size_t k=0; k&lt;s_size; ++k )
00951                 <span class="keywordflow">for</span>( node* b = s_array[k].node_list; b; b=b-&gt;next ) {
00952                     __TBB_ASSERT( &amp;get_segment(my_hash_compare.hash( b-&gt;item.first ))==&amp;d, <span class="stringliteral">"hash function changed?"</span> );
00953                     node* b_new = create_node(b-&gt;item.first, &amp;b-&gt;item.second);
00954                     d_array[k].push_front(*b_new); <span class="comment">// hashcode is the same and segment and my_physical sizes are the same</span>
00955                 }
00956         }
00957     }
00958 }
00959 
00960 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00961 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00962 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy(I first, I last) {
00963     <span class="keywordflow">for</span>(; first != last; ++first)
00964         <a class="code" href="a00177.html#a22">insert</a>( *first );
00965 }
00966 
00967 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
00968 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b) {
00969     <span class="keywordflow">if</span>(a.size() != b.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00970     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt;::const_iterator i(a.begin()), i_end(a.end());
00971     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt;::const_iterator j, j_end(b.end());
00972     <span class="keywordflow">for</span>(; i != i_end; ++i) {
00973         j = b.equal_range(i-&gt;first).first;
00974         <span class="keywordflow">if</span>( j == j_end || !(i-&gt;second == j-&gt;second) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00975     }
00976     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00977 }
00978 
00979 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
00980 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b)
00981 {    <span class="keywordflow">return</span> !(a == b); }
00982 
00983 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00984 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;a, concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;b)
00985 {    a.swap( b ); }
00986 
00987 } <span class="comment">// namespace tbb</span>
00988 
00989 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_hash_map_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
