<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>enumerable_thread_specific.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>enumerable_thread_specific.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_enumerable_thread_specific_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_enumerable_thread_specific_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "tbb/concurrent_vector.h"</span>
00025 <span class="preprocessor">#include "tbb/cache_aligned_allocator.h"</span>
00026 
00027 <span class="preprocessor">#if _WIN32||_WIN64</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
00029 <span class="preprocessor">#else</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pthread.h&gt;</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="keyword">namespace </span>tbb {
00034 
<a name="l00036"></a><a class="code" href="a00322.html#a61">00036</a>     <span class="keyword">enum</span> <a class="code" href="a00322.html#a61">ets_key_usage_type</a> { ets_single_key, ets_key_per_instance };
00037 
00039     <span class="keyword">namespace </span>internal {
00040         
00042         <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value &gt;
00043         <span class="keyword">class </span>enumerable_thread_specific_iterator 
<a name="l00044"></a><a class="code" href="a00323.html#a51">00044</a> #if <a class="code" href="a00323.html#a51">defined</a>(_WIN64) &amp;&amp; <a class="code" href="a00323.html#a51">defined</a>(_MSC_VER) 
00045             <span class="comment">// Ensure that Microsoft's internal template function _Val_type works correctly.</span>
00046             : public std::iterator&lt;std::random_access_iterator_tag,Value&gt;
00047 #endif <span class="comment">/* defined(_WIN64) &amp;&amp; defined(_MSC_VER) */</span>
00048         {
00050         
00051             Container *my_container;
00052             <span class="keyword">typename</span> Container::size_type my_index;
00053             <span class="keyword">mutable</span> Value *my_value;
00054         
00055             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;
00056             <span class="keyword">friend</span> enumerable_thread_specific_iterator&lt;C,T&gt; operator+( ptrdiff_t offset, 
00057                                                                        <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;C,T&gt;&amp; v );
00058         
00059             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00060             <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;C,T&gt;&amp; i, 
00061                                     <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;C,U&gt;&amp; j );
00062         
00063             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00064             <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt;( const enumerable_thread_specific_iterator&lt;C,T&gt;&amp; i, 
00065                                    <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;C,U&gt;&amp; j );
00066         
00067             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00068             <span class="keyword">friend</span> ptrdiff_t operator-( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;C,U&gt;&amp; j );
00069             
00070             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U&gt; 
00071             <span class="keyword">friend</span> <span class="keyword">class </span>enumerable_thread_specific_iterator;
00072         
00073             <span class="keyword">public</span>:
00074         
00075             enumerable_thread_specific_iterator( <span class="keyword">const</span> Container &amp;container, <span class="keyword">typename</span> Container::size_type index ) : 
00076                 my_container(&amp;const_cast&lt;Container &amp;&gt;(container)), my_index(index), my_value(NULL) {}
00077         
00079             enumerable_thread_specific_iterator() : my_container(NULL), my_index(0), my_value(NULL) {}
00080         
00081             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
00082             enumerable_thread_specific_iterator( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container, U&gt;&amp; other ) :
00083                     my_container( other.my_container ), my_index( other.my_index), my_value( const_cast&lt;Value *&gt;(other.my_value) ) {}
00084         
00085             enumerable_thread_specific_iterator operator+( ptrdiff_t offset )<span class="keyword"> const </span>{
00086                 <span class="keywordflow">return</span> enumerable_thread_specific_iterator(*my_container, my_index + offset);
00087             }
00088         
00089             enumerable_thread_specific_iterator &amp;operator+=( ptrdiff_t offset ) {
00090                 my_index += offset;
00091                 my_value = NULL;
00092                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00093             }
00094         
00095             enumerable_thread_specific_iterator operator-( ptrdiff_t offset )<span class="keyword"> const </span>{
00096                 <span class="keywordflow">return</span> enumerable_thread_specific_iterator( *my_container, my_index-offset );
00097             }
00098         
00099             enumerable_thread_specific_iterator &amp;operator-=( ptrdiff_t offset ) {
00100                 my_index -= offset;
00101                 my_value = NULL;
00102                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00103             }
00104         
00105             Value&amp; operator*()<span class="keyword"> const </span>{
00106                 Value* value = my_value;
00107                 <span class="keywordflow">if</span>( !value ) {
00108                     value = my_value = &amp;(*my_container)[my_index].value;
00109                 }
00110                 __TBB_ASSERT( value==&amp;(*my_container)[my_index].value, <span class="stringliteral">"corrupt cache"</span> );
00111                 <span class="keywordflow">return</span> *value;
00112             }
00113         
00114             Value&amp; operator[]( ptrdiff_t k )<span class="keyword"> const </span>{
00115                <span class="keywordflow">return</span> (*my_container)[my_index + k].value;
00116             }
00117         
00118             Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00119         
00120             enumerable_thread_specific_iterator&amp; operator++() {
00121                 ++my_index;
00122                 my_value = NULL;
00123                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00124             }
00125         
00126             enumerable_thread_specific_iterator&amp; operator--() {
00127                 --my_index;
00128                 my_value = NULL;
00129                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00130             }
00131         
00133             enumerable_thread_specific_iterator operator++(<span class="keywordtype">int</span>) {
00134                 enumerable_thread_specific_iterator result = *<span class="keyword">this</span>;
00135                 ++my_index;
00136                 my_value = NULL;
00137                 <span class="keywordflow">return</span> result;
00138             }
00139         
00141             enumerable_thread_specific_iterator operator--(<span class="keywordtype">int</span>) {
00142                 enumerable_thread_specific_iterator result = *<span class="keyword">this</span>;
00143                 --my_index;
00144                 my_value = NULL;
00145                 <span class="keywordflow">return</span> result;
00146             }
00147         
00148             <span class="comment">// STL support</span>
00149             <span class="keyword">typedef</span> ptrdiff_t difference_type;
00150             <span class="keyword">typedef</span> Value value_type;
00151             <span class="keyword">typedef</span> Value* pointer;
00152             <span class="keyword">typedef</span> Value&amp; reference;
00153             <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
00154         };
00155         
00156         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T&gt;
00157         enumerable_thread_specific_iterator&lt;Container,T&gt; operator+( ptrdiff_t offset, 
00158                                                                     <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; v ) {
00159             <span class="keywordflow">return</span> enumerable_thread_specific_iterator&lt;Container,T&gt;( v.my_container, v.my_index + offset );
00160         }
00161         
00162         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00163         <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; i, 
00164                          <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,U&gt;&amp; j ) {
00165             <span class="keywordflow">return</span> i.my_index==j.my_index;
00166         }
00167         
00168         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00169         <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; i, 
00170                          <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,U&gt;&amp; j ) {
00171             <span class="keywordflow">return</span> !(i==j);
00172         }
00173         
00174         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00175         <span class="keywordtype">bool</span> operator&lt;( const enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; i, 
00176                         <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,U&gt;&amp; j ) {
00177             <span class="keywordflow">return</span> i.my_index&lt;j.my_index;
00178         }
00179         
00180         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00181         <span class="keywordtype">bool</span> operator&gt;( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; i, 
00182                         <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,U&gt;&amp; j ) {
00183             <span class="keywordflow">return</span> j&lt;i;
00184         }
00185         
00186         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00187         <span class="keywordtype">bool</span> operator&gt;=( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; i, 
00188                          <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,U&gt;&amp; j ) {
00189             <span class="keywordflow">return</span> !(i&lt;j);
00190         }
00191         
00192         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00193         <span class="keywordtype">bool</span> operator&lt;=( const enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; i, 
00194                          <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,U&gt;&amp; j ) {
00195             <span class="keywordflow">return</span> !(j&lt;i);
00196         }
00197         
00198         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00199         ptrdiff_t operator-( <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,T&gt;&amp; i, 
00200                              <span class="keyword">const</span> enumerable_thread_specific_iterator&lt;Container,U&gt;&amp; j ) {
00201             <span class="keywordflow">return</span> i.my_index-j.my_index;
00202         }
00203 
00204     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> SegmentedContainer, <span class="keyword">typename</span> Value &gt;
00205         <span class="keyword">class </span>segmented_iterator
00206 #if <a class="code" href="a00323.html#a51">defined</a>(_WIN64) &amp;&amp; <a class="code" href="a00323.html#a51">defined</a>(_MSC_VER)
00207         : public std::iterator&lt;std::input_iterator_tag, Value&gt;
00208 #endif
00209         {
00210             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00211             <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> segmented_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> segmented_iterator&lt;C,U&gt;&amp; j);
00212 
00213             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00214             <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> segmented_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> segmented_iterator&lt;C,U&gt;&amp; j);
00215             
00216             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U&gt; 
00217             <span class="keyword">friend</span> <span class="keyword">class </span>segmented_iterator;
00218 
00219             <span class="keyword">public</span>:
00220 
00221 
00222                 segmented_iterator() {my_segcont = NULL;}
00223 
00224                 segmented_iterator( <span class="keyword">const</span> SegmentedContainer&amp; _segmented_container ) : 
00225                     my_segcont(const_cast&lt;SegmentedContainer*&gt;(&amp;_segmented_container)),
00226                     outer_iter(my_segcont-&gt;end()) { }
00227 
00228                 ~segmented_iterator() {}
00229 
00230                 <span class="keyword">typedef</span> <span class="keyword">typename</span> SegmentedContainer::iterator outer_iterator;
00231                 <span class="keyword">typedef</span> <span class="keyword">typename</span> SegmentedContainer::value_type InnerContainer;
00232                 <span class="keyword">typedef</span> <span class="keyword">typename</span> InnerContainer::iterator inner_iterator;
00233 
00234                 <span class="comment">// STL support</span>
00235                 <span class="keyword">typedef</span> ptrdiff_t difference_type;
00236                 <span class="keyword">typedef</span> Value value_type;
00237                 <span class="keyword">typedef</span> <span class="keyword">typename</span> SegmentedContainer::size_type size_type;
00238                 <span class="keyword">typedef</span> Value* pointer;
00239                 <span class="keyword">typedef</span> Value&amp; reference;
00240                 <span class="keyword">typedef</span> std::input_iterator_tag iterator_category;
00241 
00242                 <span class="comment">// Copy Constructor</span>
00243                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
00244                 segmented_iterator(<span class="keyword">const</span> segmented_iterator&lt;SegmentedContainer, U&gt;&amp; other) :
00245                     my_segcont(other.my_segcont),
00246                     outer_iter(other.outer_iter),
00247                     <span class="comment">// can we assign a default-constructed iterator to inner if we're at the end?</span>
00248                     inner_iter(other.inner_iter)
00249                 {}
00250 
00251                 <span class="comment">// assignment</span>
00252                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
00253                 segmented_iterator&amp; operator=( <span class="keyword">const</span> segmented_iterator&lt;SegmentedContainer, U&gt;&amp; other) {
00254                     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;other) {
00255                         my_segcont = other.my_segcont;
00256                         outer_iter = other.outer_iter;
00257                         <span class="keywordflow">if</span>(outer_iter != my_segcont-&gt;end()) inner_iter = other.inner_iter;
00258                     }
00259                     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00260                 }
00261 
00262                 <span class="comment">// allow assignment of outer iterator to segmented iterator.  Once it is</span>
00263                 <span class="comment">// assigned, move forward until a non-empty inner container is found or</span>
00264                 <span class="comment">// the end of the outer container is reached.</span>
00265                 segmented_iterator&amp; operator=(<span class="keyword">const</span> outer_iterator&amp; new_outer_iter) {
00266                     __TBB_ASSERT(my_segcont != NULL, NULL);
00267                     <span class="comment">// check that this iterator points to something inside the segmented container</span>
00268                     <span class="keywordflow">for</span>(outer_iter = new_outer_iter ;outer_iter!=my_segcont-&gt;end(); ++outer_iter) {
00269                         <span class="keywordflow">if</span>( !outer_iter-&gt;empty() ) {
00270                             inner_iter = outer_iter-&gt;begin();
00271                             <span class="keywordflow">break</span>;
00272                         }
00273                     }
00274                     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00275                 }
00276 
00277                 <span class="comment">// pre-increment</span>
00278                 segmented_iterator&amp; operator++() {
00279                     advance_me();
00280                     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00281                 }
00282 
00283                 <span class="comment">// post-increment</span>
00284                 segmented_iterator operator++(<span class="keywordtype">int</span>) {
00285                     segmented_iterator tmp = *<span class="keyword">this</span>;
00286                     operator++();
00287                     <span class="keywordflow">return</span> tmp;
00288                 }
00289 
00290                 <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> outer_iterator&amp; other_outer)<span class="keyword"> const </span>{
00291                     __TBB_ASSERT(my_segcont != NULL, NULL);
00292                     <span class="keywordflow">return</span> (outer_iter == other_outer &amp;&amp;
00293                             (outer_iter == my_segcont-&gt;end() || inner_iter == outer_iter-&gt;begin()));
00294                 }
00295 
00296                 <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> outer_iterator&amp; other_outer)<span class="keyword"> const </span>{
00297                     <span class="keywordflow">return</span> !operator==(other_outer);
00298 
00299                 }
00300 
00301                 <span class="comment">// (i)* RHS</span>
00302                 reference operator*()<span class="keyword"> const </span>{
00303                     __TBB_ASSERT(my_segcont != NULL, NULL);
00304                     __TBB_ASSERT(outer_iter != my_segcont-&gt;end(), <span class="stringliteral">"Dereferencing a pointer at end of container"</span>);
00305                     __TBB_ASSERT(inner_iter != outer_iter-&gt;end(), NULL); <span class="comment">// should never happen</span>
00306                     <span class="keywordflow">return</span> *inner_iter;
00307                 }
00308 
00309                 <span class="comment">// i-&gt;</span>
00310                 pointer operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;operator*();}
00311 
00312                 size_type size() {
00313                     __TBB_ASSERT(my_segcont, NULL);
00314                     size_type tot_size = 0;
00315                     <span class="keywordflow">for</span>(outer_iterator oi = my_segcont-&gt;begin(); oi != my_segcont-&gt;end(); ++oi) {
00316                         tot_size += oi-&gt;size();
00317                     }
00318                     <span class="keywordflow">return</span> tot_size;
00319                 }
00320 
00321             <span class="keyword">private</span>:
00322                 SegmentedContainer*             my_segcont;
00323                 outer_iterator outer_iter;
00324                 inner_iterator inner_iter;
00325 
00326                 <span class="keywordtype">void</span> advance_me() {
00327                     __TBB_ASSERT(my_segcont != NULL, NULL);
00328                     __TBB_ASSERT(outer_iter != my_segcont-&gt;end(), NULL); <span class="comment">// not true if there are no inner containers</span>
00329                     __TBB_ASSERT(inner_iter != outer_iter-&gt;end(), NULL); <span class="comment">// not true if the inner containers are all empty.</span>
00330                     ++inner_iter;
00331                     <span class="keywordflow">while</span>(inner_iter == outer_iter-&gt;end() &amp;&amp; ++outer_iter != my_segcont-&gt;end()) {
00332                         inner_iter = outer_iter-&gt;begin();
00333                     }
00334                 }
00335         };    <span class="comment">// segmented_iterator</span>
00336 
00337         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> SegmentedContainer, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00338         <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> segmented_iterator&lt;SegmentedContainer,T&gt;&amp; i, 
00339                          <span class="keyword">const</span> segmented_iterator&lt;SegmentedContainer,U&gt;&amp; j ) {
00340             <span class="keywordflow">if</span>(i.my_segcont != j.my_segcont) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00341             <span class="keywordflow">if</span>(i.my_segcont == NULL) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00342             <span class="keywordflow">if</span>(i.outer_iter != j.outer_iter) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00343             <span class="keywordflow">if</span>(i.outer_iter == i.my_segcont-&gt;end()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00344             <span class="keywordflow">return</span> i.inner_iter == j.inner_iter;
00345         }
00346 
00347         <span class="comment">// !=</span>
00348         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> SegmentedContainer, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00349         <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> segmented_iterator&lt;SegmentedContainer,T&gt;&amp; i, 
00350                          <span class="keyword">const</span> segmented_iterator&lt;SegmentedContainer,U&gt;&amp; j ) {
00351             <span class="keywordflow">return</span> !(i==j);
00352         }
00353 
<a name="l00355"></a><a class="code" href="a00279.html">00355</a>         <span class="keyword">struct </span><a class="code" href="a00279.html">tls_single_key_manager_v4</a> {
00356             <span class="keyword">typedef</span> <a class="code" href="a00213.html">tbb::concurrent_vector&lt;void *&gt;</a>::size_type tls_key_t;
00357             <span class="keyword">static</span> <span class="keywordtype">void</span> __TBB_EXPORTED_FUNC create_key( tls_key_t &amp;k);
00358             <span class="keyword">static</span> <span class="keywordtype">void</span> __TBB_EXPORTED_FUNC destroy_key( tls_key_t &amp;k );
00359             <span class="keyword">static</span> <span class="keywordtype">void</span> __TBB_EXPORTED_FUNC set_tls( tls_key_t &amp;k, <span class="keywordtype">void</span> * value );
00360             <span class="keyword">static</span> <span class="keywordtype">void</span> * __TBB_EXPORTED_FUNC get_tls( tls_key_t &amp;k );
00361         };
00362 
00363         <span class="comment">// empty template for following specializations</span>
00364         <span class="keyword">template</span>&lt;ets_key_usage_type et&gt;
00365         <span class="keyword">struct </span>tls_manager {};
00366         
00368         <span class="keyword">template</span> &lt;&gt;
<a name="l00369"></a><a class="code" href="a00278.html">00369</a>         <span class="keyword">struct </span>tls_manager&lt;ets_single_key&gt; {
00370             <span class="keyword">typedef</span> tls_single_key_manager_v4::tls_key_t tls_key_t;
00371             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> create_key( tls_key_t &amp;k) { internal::tls_single_key_manager_v4::create_key(k); }
00372             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> destroy_key( tls_key_t &amp;k ) { internal::tls_single_key_manager_v4::destroy_key(k); }
00373             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_tls( tls_key_t &amp;k, <span class="keywordtype">void</span> * value ) { 
00374                 internal::tls_single_key_manager_v4::set_tls(k, value); 
00375             }
00376             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> * get_tls( tls_key_t &amp;k ) { <span class="keywordflow">return</span> internal::tls_single_key_manager_v4::get_tls(k); }
00377         };
00378 
00379         
00381         <span class="keyword">template</span> &lt;&gt;
<a name="l00382"></a><a class="code" href="a00277.html">00382</a>         <span class="keyword">struct </span>tls_manager &lt;ets_key_per_instance&gt; {
00383 <span class="preprocessor">#if _WIN32||_WIN64</span>
00384 <span class="preprocessor"></span>            <span class="keyword">typedef</span> DWORD tls_key_t;
00385             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> create_key( tls_key_t &amp;k) { k = TlsAlloc(); }
00386             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> destroy_key( tls_key_t &amp;k) { TlsFree(k); }
00387             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_tls( tls_key_t &amp;k, <span class="keywordtype">void</span> * value) { TlsSetValue(k, (LPVOID)value); }
00388             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> * get_tls( tls_key_t &amp;k ) { <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)TlsGetValue(k); }
00389 <span class="preprocessor">#else</span>
00390 <span class="preprocessor"></span>            <span class="keyword">typedef</span> pthread_key_t tls_key_t;
00391             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> create_key( tls_key_t &amp;k) { pthread_key_create(&amp;k, NULL); }
00392             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> destroy_key( tls_key_t &amp;k) { pthread_key_delete(k); }
00393             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_tls( tls_key_t &amp;k, <span class="keywordtype">void</span> * value) { pthread_setspecific(k, value); }
00394             <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> * get_tls( tls_key_t &amp;k ) { <span class="keywordflow">return</span> pthread_getspecific(k); }
00395 <span class="preprocessor">#endif</span>
00396 <span class="preprocessor"></span>        };
00397 
00398     } <span class="comment">// namespace internal</span>
00400 <span class="comment"></span>
00402     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, 
00403               <span class="keyword">typename</span> Allocator=<a class="code" href="a00202.html">cache_aligned_allocator&lt;T&gt;</a>, 
00404               <a class="code" href="a00322.html#a61">ets_key_usage_type</a> ETS_key_type=ets_single_key &gt; 
<a name="l00405"></a><a class="code" href="a00220.html">00405</a>     <span class="keyword">class </span><a class="code" href="a00220.html">enumerable_thread_specific</a> { 
00406     
00407         <span class="keyword">typedef</span> internal::tls_manager&lt; ETS_key_type &gt; my_tls_manager;
00408 
00410         <span class="keyword">struct </span>padded_element {
00411             T value;
00412             <span class="keywordtype">char</span> padding[ ( (<span class="keyword">sizeof</span>(T) - 1) / internal::NFS_MaxLineSize + 1 ) * internal::NFS_MaxLineSize - <span class="keyword">sizeof</span>(T) ];
00413             padded_element(<span class="keyword">const</span> T &amp;v) : value(v) {}
00414             padded_element() {}
00415         };
00416     
00418         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00419         <span class="keyword">class </span>generic_range_type: <span class="keyword">public</span> <a class="code" href="a00199.html">blocked_range</a>&lt;I&gt; {
00420         <span class="keyword">public</span>:
00421             <span class="keyword">typedef</span> T value_type;
00422             <span class="keyword">typedef</span> T&amp; reference;
00423             <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;
00424             <span class="keyword">typedef</span> I iterator;
00425             <span class="keyword">typedef</span> ptrdiff_t difference_type;
00426             generic_range_type( I begin_, I end_, size_t grainsize = 1) : <a class="code" href="a00199.html">blocked_range&lt;I&gt;</a>(begin_,end_,grainsize) {} 
00427             <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
00428             generic_range_type( <span class="keyword">const</span> generic_range_type&lt;U&gt;&amp; r) : <a class="code" href="a00199.html">blocked_range&lt;I&gt;</a>(r.begin(),r.end(),r.grainsize()) {} 
00429             generic_range_type( generic_range_type&amp; r, <a class="code" href="a00257.html">split</a> ) : <a class="code" href="a00199.html">blocked_range&lt;I&gt;</a>(r,<a class="code" href="a00257.html">split</a>()) {}
00430         };
00431     
00432         <span class="keyword">typedef</span> <span class="keyword">typename</span> Allocator::template rebind&lt; padded_element &gt;::other padded_allocator_type;
00433         <span class="keyword">typedef</span> <a class="code" href="a00213.html">tbb::concurrent_vector&lt; padded_element, padded_allocator_type &gt;</a> <a class="code" href="a00213.html">internal_collection_type</a>;
00434     
00435         <span class="keyword">typename</span> my_tls_manager::tls_key_t my_key;
00436         padded_element my_exemplar;
00437         internal_collection_type my_locals;
00438     
00439     <span class="keyword">public</span>:
00440     
<a name="l00442"></a><a class="code" href="a00220.html#w0">00442</a>         <span class="keyword">typedef</span> Allocator allocator_type;
00443         <span class="keyword">typedef</span> T value_type;
00444         <span class="keyword">typedef</span> T&amp; reference;
00445         <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;
00446         <span class="keyword">typedef</span> T* pointer;
00447         <span class="keyword">typedef</span> <span class="keyword">typename</span> internal_collection_type::size_type size_type;
00448         <span class="keyword">typedef</span> <span class="keyword">typename</span> internal_collection_type::difference_type difference_type;
00449     
00450         <span class="comment">// Iterator types</span>
00451         <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::enumerable_thread_specific_iterator&lt; internal_collection_type, value_type &gt; iterator;
00452         <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::enumerable_thread_specific_iterator&lt; internal_collection_type, const value_type &gt; const_iterator;
00453 
00454         <span class="comment">// Parallel range types</span>
00455         <span class="keyword">typedef</span> generic_range_type&lt; iterator &gt; range_type;
00456         <span class="keyword">typedef</span> generic_range_type&lt; const_iterator &gt; const_range_type;
00457     
<a name="l00459"></a><a class="code" href="a00220.html#a0">00459</a>         <a class="code" href="a00220.html">enumerable_thread_specific</a>() { 
00460             my_tls_manager::create_key(my_key); 
00461         }
00462     
<a name="l00464"></a><a class="code" href="a00220.html#a1">00464</a>         <a class="code" href="a00220.html">enumerable_thread_specific</a>(<span class="keyword">const</span> T &amp;_exemplar) : my_exemplar(_exemplar) {
00465             my_tls_manager::create_key(my_key); 
00466         }
00467     
<a name="l00469"></a><a class="code" href="a00220.html#a2">00469</a>         ~<a class="code" href="a00220.html">enumerable_thread_specific</a>() { 
00470             my_tls_manager::destroy_key(my_key); 
00471         }
00472       
00473     
<a name="l00475"></a><a class="code" href="a00220.html#a3">00475</a>         reference local()  {
00476             <span class="keywordflow">if</span> ( pointer local_ptr = static_cast&lt; pointer &gt;(my_tls_manager::get_tls(my_key)) ) {
00477                <span class="keywordflow">return</span> *local_ptr;
00478             } <span class="keywordflow">else</span> {
00479                 <span class="keyword">typename</span> internal_collection_type::size_type local_index = my_locals.<a class="code" href="a00213.html#a11">push_back</a>( my_exemplar );
00480                 reference local_ref = my_locals[local_index].value;
00481                 my_tls_manager::set_tls( my_key, static_cast&lt;void *&gt;(&amp;local_ref) );
00482                 <span class="keywordflow">return</span> local_ref;
00483             }
00484         }
00485 
<a name="l00487"></a><a class="code" href="a00220.html#a4">00487</a>         size_type size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> my_locals.<a class="code" href="a00213.html#a18">size</a>(); }
00488     
<a name="l00490"></a><a class="code" href="a00220.html#a5">00490</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> my_locals.<a class="code" href="a00213.html#a19">empty</a>(); }
00491     
<a name="l00493"></a><a class="code" href="a00220.html#a6">00493</a>         iterator begin() { <span class="keywordflow">return</span> iterator( my_locals, 0 ); }
<a name="l00495"></a><a class="code" href="a00220.html#a7">00495</a>         iterator end() { <span class="keywordflow">return</span> iterator(my_locals, my_locals.<a class="code" href="a00213.html#a18">size</a>() ); }
00496     
<a name="l00498"></a><a class="code" href="a00220.html#a8">00498</a>         const_iterator begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_iterator(my_locals, 0); }
00499     
<a name="l00501"></a><a class="code" href="a00220.html#a9">00501</a>         const_iterator end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_iterator(my_locals, my_locals.<a class="code" href="a00213.html#a18">size</a>()); }
00502 
<a name="l00504"></a><a class="code" href="a00220.html#a10">00504</a>         range_type range( size_t grainsize=1 ) { <span class="keywordflow">return</span> range_type( begin(), end(), grainsize ); } 
00505         
<a name="l00507"></a><a class="code" href="a00220.html#a11">00507</a>         const_range_type range( size_t grainsize=1 )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_range_type( begin(), end(), grainsize ); }
00508     
<a name="l00510"></a><a class="code" href="a00220.html#a12">00510</a>         <span class="keywordtype">void</span> clear() {
00511             my_locals.<a class="code" href="a00213.html#a40">clear</a>();
00512             my_tls_manager::destroy_key(my_key);
00513             my_tls_manager::create_key(my_key); 
00514         }
00515     
00516     };
00517 
00518     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Container &gt;
00519     <span class="keyword">class </span>flattened2d {
00520     <span class="keyword">public</span>:
00521 
00523         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::size_type size_type;
00524         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::difference_type difference_type;
00525         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::allocator_type allocator_type;
00526         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::value_type value_type;
00527         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::reference reference;
00528         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::const_reference const_reference;
00529         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::pointer pointer;
00530         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::value_type::const_pointer const_pointer;
00531 
00532         <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::segmented_iterator&lt;Container, value_type&gt; iterator;
00533         <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::segmented_iterator&lt;Container, const value_type&gt; const_iterator;
00534 
00535         flattened2d( <span class="keyword">const</span> Container &amp;c, <span class="keyword">typename</span> Container::const_iterator b, <span class="keyword">typename</span> Container::const_iterator e ) : 
00536             my_container(const_cast&lt;Container &amp;&gt;(c)), my_begin(b), my_end(e) { }
00537 
00538         flattened2d( <span class="keyword">const</span> Container &amp;c ) : 
00539             my_container(const_cast&lt;Container &amp;&gt;(c)), my_begin(c.begin()), my_end(c.end()) { }
00540 
00541         iterator begin() { <span class="keywordflow">return</span> iterator(my_container) = my_begin; }
00542         iterator end() { <span class="keywordflow">return</span> iterator(my_container) = my_end; }
00543         const_iterator begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_iterator(my_container) = my_begin; }
00544         const_iterator end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_iterator(my_container) = my_end; }
00545 
00546         size_type size()<span class="keyword"> const </span>{
00547             size_type tot_size = 0;
00548             <span class="keywordflow">for</span>(<span class="keyword">typename</span> Container::const_iterator i = my_begin; i != my_end; ++i) {
00549                 tot_size += i-&gt;<a class="code" href="a00213.html#a18">size</a>();
00550             }
00551             <span class="keywordflow">return</span> tot_size;
00552         }
00553 
00554     <span class="keyword">private</span>:
00555 
00556         Container &amp;my_container;
00557         <span class="keyword">typename</span> Container::const_iterator my_begin;
00558         <span class="keyword">typename</span> Container::const_iterator my_end;
00559 
00560     };
00561 
00562     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;
00563     flattened2d&lt;Container&gt; flatten2d(<span class="keyword">const</span> Container &amp;c, <span class="keyword">const</span> <span class="keyword">typename</span> Container::const_iterator b, <span class="keyword">const</span> <span class="keyword">typename</span> Container::const_iterator e) {
00564         <span class="keywordflow">return</span> flattened2d&lt;Container&gt;(c, b, e);
00565     }
00566 
00567     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;
00568     flattened2d&lt;Container&gt; flatten2d(<span class="keyword">const</span> Container &amp;c) {
00569         <span class="keywordflow">return</span> flattened2d&lt;Container&gt;(c);
00570     }
00571 
00572 } <span class="comment">// namespace tbb</span>
00573 
00574 <span class="preprocessor">#endif</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
